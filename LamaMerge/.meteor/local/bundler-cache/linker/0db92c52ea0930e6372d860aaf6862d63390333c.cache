[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar meteorBabelHelpers;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"babel-runtime\":{\"babel-runtime.js\":[\"meteor-babel-helpers\",\"regenerator/runtime-module\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/babel-runtime/babel-runtime.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                              // 1\nvar S = typeof Symbol === \"function\" ? Symbol : {};                                                        // 2\nvar iteratorSymbol = S.iterator || \"@@iterator\";                                                           // 3\n                                                                                                           // 4\nmeteorBabelHelpers = require(\"meteor-babel-helpers\");                                                      // 5\n                                                                                                           // 6\nvar BabelRuntime = {                                                                                       // 7\n  // es6.templateLiterals                                                                                  // 8\n  // Constructs the object passed to the tag function in a tagged                                          // 9\n  // template literal.                                                                                     // 10\n  taggedTemplateLiteralLoose: function (strings, raw) {                                                    // 11\n    // Babel's own version of this calls Object.freeze on `strings` and                                    // 12\n    // `strings.raw`, but it doesn't seem worth the compatibility and                                      // 13\n    // performance concerns.  If you're writing code against this helper,                                  // 14\n    // don't add properties to these objects.                                                              // 15\n    strings.raw = raw;                                                                                     // 16\n    return strings;                                                                                        // 17\n  },                                                                                                       // 18\n                                                                                                           // 19\n  // es6.classes                                                                                           // 20\n  // Checks that a class constructor is being called with `new`, and throws                                // 21\n  // an error if it is not.                                                                                // 22\n  classCallCheck: function (instance, Constructor) {                                                       // 23\n    if (!(instance instanceof Constructor)) {                                                              // 24\n      throw new TypeError(\"Cannot call a class as a function\");                                            // 25\n    }                                                                                                      // 26\n  },                                                                                                       // 27\n                                                                                                           // 28\n  // es6.classes                                                                                           // 29\n  inherits: function (subClass, superClass) {                                                              // 30\n    if (typeof superClass !== \"function\" && superClass !== null) {                                         // 31\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }                                                                                                      // 33\n                                                                                                           // 34\n    if (superClass) {                                                                                      // 35\n      if (Object.create) {                                                                                 // 36\n        // All but IE 8                                                                                    // 37\n        subClass.prototype = Object.create(superClass.prototype, {                                         // 38\n          constructor: {                                                                                   // 39\n            value: subClass,                                                                               // 40\n            enumerable: false,                                                                             // 41\n            writable: true,                                                                                // 42\n            configurable: true                                                                             // 43\n          }                                                                                                // 44\n        });                                                                                                // 45\n      } else {                                                                                             // 46\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`                           // 47\n        // is enumerable and shows up in the inspector unnecessarily.                                      // 48\n        // It's not an \"own\" property of any instance though.                                              // 49\n        //                                                                                                 // 50\n        // For correctness when writing code,                                                              // 51\n        // don't enumerate all the own-and-inherited properties of an instance                             // 52\n        // of a class and expect not to find `constructor` (but who does that?).                           // 53\n        var F = function () {                                                                              // 54\n          this.constructor = subClass;                                                                     // 55\n        };                                                                                                 // 56\n        F.prototype = superClass.prototype;                                                                // 57\n        subClass.prototype = new F();                                                                      // 58\n      }                                                                                                    // 59\n                                                                                                           // 60\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,                             // 61\n      // but IE <=10 don't support `__proto__`, and in this case the difference                            // 62\n      // would be detectable; code that works in modern browsers could easily                              // 63\n      // fail on IE 8 if we ever used the `__proto__` trick.                                               // 64\n      //                                                                                                   // 65\n      // There's no perfect way to make static methods inherited if they are                               // 66\n      // assigned after declaration of the classes.  The best we can do is                                 // 67\n      // to copy them.  In other words, when you write `class Foo                                          // 68\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future                            // 69\n      // ones are not copied.                                                                              // 70\n      //                                                                                                   // 71\n      // For correctness when writing code, don't add static methods to a class                            // 72\n      // after you subclass it.                                                                            // 73\n                                                                                                           // 74\n      // The ecmascript-runtime package provides adequate polyfills for                                    // 75\n      // all of these Object.* functions (and Array#forEach), and anyone                                   // 76\n      // using babel-runtime is almost certainly using it because of the                                   // 77\n      // ecmascript package, which also implies ecmascript-runtime.                                        // 78\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {                                        // 79\n        // This property descriptor dance preserves getter/setter behavior                                 // 80\n        // in browsers that support accessor properties (all except                                        // 81\n        // IE8). In IE8, the superClass can't have accessor properties                                     // 82\n        // anyway, so this code is still safe.                                                             // 83\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);                                   // 84\n        if (descriptor && typeof descriptor === \"object\") {                                                // 85\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {                                              // 86\n            // If subClass already has a property by this name, then it                                    // 87\n            // would not be inherited, so it should not be copied. This                                    // 88\n            // notably excludes properties like .prototype and .name.                                      // 89\n            return;                                                                                        // 90\n          }                                                                                                // 91\n                                                                                                           // 92\n          Object.defineProperty(subClass, k, descriptor);                                                  // 93\n        }                                                                                                  // 94\n      });                                                                                                  // 95\n    }                                                                                                      // 96\n  },                                                                                                       // 97\n                                                                                                           // 98\n  createClass: (function () {                                                                              // 99\n    var hasDefineProperty = false;                                                                         // 100\n    try {                                                                                                  // 101\n      // IE 8 has a broken Object.defineProperty, so feature-test by                                       // 102\n      // trying to call it.                                                                                // 103\n      Object.defineProperty({}, 'x', {});                                                                  // 104\n      hasDefineProperty = true;                                                                            // 105\n    } catch (e) {}                                                                                         // 106\n                                                                                                           // 107\n    function defineProperties(target, props) {                                                             // 108\n      for (var i = 0; i < props.length; i++) {                                                             // 109\n        var descriptor = props[i];                                                                         // 110\n        descriptor.enumerable = descriptor.enumerable || false;                                            // 111\n        descriptor.configurable = true;                                                                    // 112\n        if (\"value\" in descriptor) descriptor.writable = true;                                             // 113\n        Object.defineProperty(target, descriptor.key, descriptor);                                         // 114\n      }                                                                                                    // 115\n    }                                                                                                      // 116\n                                                                                                           // 117\n    return function (Constructor, protoProps, staticProps) {                                               // 118\n      if (! hasDefineProperty) {                                                                           // 119\n        // e.g. `class Foo { get bar() {} }`.  If you try to use getters and                               // 120\n        // setters in IE 8, you will get a big nasty error, with or without                                // 121\n        // Babel.  I don't know of any other syntax features besides getters                               // 122\n        // and setters that will trigger this error.                                                       // 123\n        throw new Error(                                                                                   // 124\n          \"Your browser does not support this type of class property.  \" +                                 // 125\n            \"For example, Internet Explorer 8 does not support getters and \" +                             // 126\n            \"setters.\");                                                                                   // 127\n      }                                                                                                    // 128\n                                                                                                           // 129\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);                                 // 130\n      if (staticProps) defineProperties(Constructor, staticProps);                                         // 131\n      return Constructor;                                                                                  // 132\n    };                                                                                                     // 133\n  })(),                                                                                                    // 134\n                                                                                                           // 135\n  \"typeof\": function (obj) {                                                                               // 136\n    return obj && obj.constructor === Symbol ? \"symbol\" : typeof obj;                                      // 137\n  },                                                                                                       // 138\n                                                                                                           // 139\n  possibleConstructorReturn: function (self, call) {                                                       // 140\n    if (! self) {                                                                                          // 141\n      throw new ReferenceError(                                                                            // 142\n        \"this hasn't been initialised - super() hasn't been called\"                                        // 143\n      );                                                                                                   // 144\n    }                                                                                                      // 145\n                                                                                                           // 146\n    var callType = typeof call;                                                                            // 147\n    if (call &&                                                                                            // 148\n        callType === \"function\" ||                                                                         // 149\n        callType === \"object\") {                                                                           // 150\n      return call;                                                                                         // 151\n    }                                                                                                      // 152\n                                                                                                           // 153\n    return self;                                                                                           // 154\n  },                                                                                                       // 155\n                                                                                                           // 156\n  interopRequireDefault: function (obj) {                                                                  // 157\n    return obj && obj.__esModule ? obj : { 'default': obj };                                               // 158\n  },                                                                                                       // 159\n                                                                                                           // 160\n  interopRequireWildcard: function (obj) {                                                                 // 161\n    if (obj && obj.__esModule) {                                                                           // 162\n      return obj;                                                                                          // 163\n    }                                                                                                      // 164\n                                                                                                           // 165\n    var newObj = {};                                                                                       // 166\n                                                                                                           // 167\n    if (obj != null) {                                                                                     // 168\n      for (var key in obj) {                                                                               // 169\n        if (hasOwn.call(obj, key)) {                                                                       // 170\n          newObj[key] = obj[key];                                                                          // 171\n        }                                                                                                  // 172\n      }                                                                                                    // 173\n    }                                                                                                      // 174\n                                                                                                           // 175\n    newObj[\"default\"] = obj;                                                                               // 176\n    return newObj;                                                                                         // 177\n  },                                                                                                       // 178\n                                                                                                           // 179\n  interopExportWildcard: function (obj, defaults) {                                                        // 180\n    var newObj = defaults({}, obj);                                                                        // 181\n    delete newObj[\"default\"];                                                                              // 182\n    return newObj;                                                                                         // 183\n  },                                                                                                       // 184\n                                                                                                           // 185\n  defaults: function (obj, defaults) {                                                                     // 186\n    Object.getOwnPropertyNames(defaults).forEach(function (key) {                                          // 187\n      var desc = Object.getOwnPropertyDescriptor(defaults, key);                                           // 188\n      if (desc && desc.configurable && typeof obj[key] === \"undefined\") {                                  // 189\n        Object.defineProperty(obj, key, desc);                                                             // 190\n      }                                                                                                    // 191\n    });                                                                                                    // 192\n                                                                                                           // 193\n    return obj;                                                                                            // 194\n  },                                                                                                       // 195\n                                                                                                           // 196\n  // es7.objectRestSpread and react (JSX)                                                                  // 197\n  \"extends\": Object.assign || (function (target) {                                                         // 198\n    for (var i = 1; i < arguments.length; i++) {                                                           // 199\n      var source = arguments[i];                                                                           // 200\n      for (var key in source) {                                                                            // 201\n        if (hasOwn.call(source, key)) {                                                                    // 202\n          target[key] = source[key];                                                                       // 203\n        }                                                                                                  // 204\n      }                                                                                                    // 205\n    }                                                                                                      // 206\n    return target;                                                                                         // 207\n  }),                                                                                                      // 208\n                                                                                                           // 209\n  // es6.destructuring                                                                                     // 210\n  objectWithoutProperties: function (obj, keys) {                                                          // 211\n    var target = {};                                                                                       // 212\n    outer: for (var i in obj) {                                                                            // 213\n      if (! hasOwn.call(obj, i)) continue;                                                                 // 214\n      for (var j = 0; j < keys.length; j++) {                                                              // 215\n        if (keys[j] === i) continue outer;                                                                 // 216\n      }                                                                                                    // 217\n      target[i] = obj[i];                                                                                  // 218\n    }                                                                                                      // 219\n    return target;                                                                                         // 220\n  },                                                                                                       // 221\n                                                                                                           // 222\n  // es6.destructuring                                                                                     // 223\n  objectDestructuringEmpty: function (obj) {                                                               // 224\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");                                  // 225\n  },                                                                                                       // 226\n                                                                                                           // 227\n  // es6.spread                                                                                            // 228\n  bind: Function.prototype.bind || (function () {                                                          // 229\n    var isCallable = function (value) { return typeof value === 'function'; };                             // 230\n    var $Object = Object;                                                                                  // 231\n    var to_string = Object.prototype.toString;                                                             // 232\n    var array_slice = Array.prototype.slice;                                                               // 233\n    var array_concat = Array.prototype.concat;                                                             // 234\n    var array_push = Array.prototype.push;                                                                 // 235\n    var max = Math.max;                                                                                    // 236\n    var Empty = function Empty() {};                                                                       // 237\n                                                                                                           // 238\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.                                 // 239\n    return function bind(that) {                                                                           // 240\n      var target = this;                                                                                   // 241\n      if (!isCallable(target)) {                                                                           // 242\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);                   // 243\n      }                                                                                                    // 244\n                                                                                                           // 245\n      var args = array_slice.call(arguments, 1);                                                           // 246\n                                                                                                           // 247\n      var bound;                                                                                           // 248\n      var binder = function () {                                                                           // 249\n                                                                                                           // 250\n        if (this instanceof bound) {                                                                       // 251\n          var result = target.apply(                                                                       // 252\n            this,                                                                                          // 253\n            array_concat.call(args, array_slice.call(arguments))                                           // 254\n          );                                                                                               // 255\n          if ($Object(result) === result) {                                                                // 256\n            return result;                                                                                 // 257\n          }                                                                                                // 258\n          return this;                                                                                     // 259\n        } else {                                                                                           // 260\n          return target.apply(                                                                             // 261\n            that,                                                                                          // 262\n            array_concat.call(args, array_slice.call(arguments))                                           // 263\n          );                                                                                               // 264\n        }                                                                                                  // 265\n      };                                                                                                   // 266\n                                                                                                           // 267\n      var boundLength = max(0, target.length - args.length);                                               // 268\n                                                                                                           // 269\n      var boundArgs = [];                                                                                  // 270\n      for (var i = 0; i < boundLength; i++) {                                                              // 271\n        array_push.call(boundArgs, '$' + i);                                                               // 272\n      }                                                                                                    // 273\n                                                                                                           // 274\n      // Create a Function from source code so that it has the right `.length`.                            // 275\n      // Probably not important for Babel.  This code violates CSPs that ban                               // 276\n      // `eval`, but the browsers that need this polyfill don't have CSP!                                  // 277\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n                                                                                                           // 279\n      if (target.prototype) {                                                                              // 280\n        Empty.prototype = target.prototype;                                                                // 281\n        bound.prototype = new Empty();                                                                     // 282\n        Empty.prototype = null;                                                                            // 283\n      }                                                                                                    // 284\n                                                                                                           // 285\n      return bound;                                                                                        // 286\n    };                                                                                                     // 287\n                                                                                                           // 288\n  })(),                                                                                                    // 289\n                                                                                                           // 290\n  toConsumableArray: function (arr) {                                                                      // 291\n    if (Array.isArray(arr)) {                                                                              // 292\n      for (var i = arr.length - 1, arr2 = Array(i + 1); i >= 0; --i) {                                     // 293\n        arr2[i] = arr[i];                                                                                  // 294\n      }                                                                                                    // 295\n                                                                                                           // 296\n      return arr2;                                                                                         // 297\n    }                                                                                                      // 298\n                                                                                                           // 299\n    return Array.from(arr);                                                                                // 300\n  },                                                                                                       // 301\n                                                                                                           // 302\n  toArray: function (arr) {                                                                                // 303\n    return Array.isArray(arr) ? arr : Array.from(arr);                                                     // 304\n  },                                                                                                       // 305\n                                                                                                           // 306\n  slicedToArray: function (iterable, limit) {                                                              // 307\n    if (Array.isArray(iterable)) {                                                                         // 308\n      return iterable;                                                                                     // 309\n    }                                                                                                      // 310\n                                                                                                           // 311\n    if (iterable) {                                                                                        // 312\n      var it = iterable[iteratorSymbol]();                                                                 // 313\n      var result = [];                                                                                     // 314\n      var info;                                                                                            // 315\n                                                                                                           // 316\n      if (typeof limit !== \"number\") {                                                                     // 317\n        limit = Infinity;                                                                                  // 318\n      }                                                                                                    // 319\n                                                                                                           // 320\n      while (result.length < limit &&                                                                      // 321\n             ! (info = it.next()).done) {                                                                  // 322\n        result.push(info.value);                                                                           // 323\n      }                                                                                                    // 324\n                                                                                                           // 325\n      return result;                                                                                       // 326\n    }                                                                                                      // 327\n                                                                                                           // 328\n    throw new TypeError(                                                                                   // 329\n      \"Invalid attempt to destructure non-iterable instance\"                                               // 330\n    );                                                                                                     // 331\n  },                                                                                                       // 332\n                                                                                                           // 333\n  slice: Array.prototype.slice                                                                             // 334\n};                                                                                                         // 335\n                                                                                                           // 336\n// Use meteorInstall to install all of the above helper functions within                                   // 337\n// node_modules/babel-runtime/helpers.                                                                     // 338\nObject.keys(BabelRuntime).forEach(function (helperName) {                                                  // 339\n  var helpers = {};                                                                                        // 340\n                                                                                                           // 341\n  helpers[helperName + \".js\"] = function (require, exports, module) {                                      // 342\n    module.exports = BabelRuntime[helperName];                                                             // 343\n  };                                                                                                       // 344\n                                                                                                           // 345\n  meteorInstall({                                                                                          // 346\n    node_modules: {                                                                                        // 347\n      \"babel-runtime\": {                                                                                   // 348\n        helpers: helpers                                                                                   // 349\n      }                                                                                                    // 350\n    }                                                                                                      // 351\n  });                                                                                                      // 352\n});                                                                                                        // 353\n                                                                                                           // 354\n// Use meteorInstall to install the regenerator runtime at                                                 // 355\n// node_modules/babel-runtime/regenerator.                                                                 // 356\nmeteorInstall({                                                                                            // 357\n  node_modules: {                                                                                          // 358\n    \"babel-runtime\": {                                                                                     // 359\n      \"regenerator.js\": function (r, e, module) {                                                          // 360\n        // Note that we use the require function provided to the                                           // 361\n        // babel-runtime.js file, not the one named 'r' above.                                             // 362\n        var runtime = require(\"regenerator/runtime-module\");                                               // 363\n                                                                                                           // 364\n        // If Promise.asyncApply is defined, use it to wrap calls to                                       // 365\n        // runtime.async so that the entire async function will run in its                                 // 366\n        // own Fiber, not just the code that comes after the first await.                                  // 367\n        if (typeof Promise === \"function\" &&                                                               // 368\n            typeof Promise.asyncApply === \"function\") {                                                    // 369\n          var realAsync = runtime.async;                                                                   // 370\n          runtime.async = function () {                                                                    // 371\n            return Promise.asyncApply(realAsync, runtime, arguments);                                      // 372\n          };                                                                                               // 373\n        }                                                                                                  // 374\n                                                                                                           // 375\n        module.exports = runtime;                                                                          // 376\n      }                                                                                                    // 377\n    }                                                                                                      // 378\n  }                                                                                                        // 379\n});                                                                                                        // 380\n                                                                                                           // 381\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"meteor-babel-helpers\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// ../npm/node_modules/meteor-babel-helpers/package.json                                                   //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nexports.name = \"meteor-babel-helpers\";                                                                     // 1\nexports.version = \"0.0.3\";                                                                                 // 2\nexports.main = \"index.js\";                                                                                 // 3\n                                                                                                           // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/meteor-babel-helpers/index.js                            //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nfunction canDefineNonEnumerableProperties() {                                                              // 1\n  var testObj = {};                                                                                        // 2\n  var testPropName = \"t\";                                                                                  // 3\n                                                                                                           // 4\n  try {                                                                                                    // 5\n    Object.defineProperty(testObj, testPropName, {                                                         // 6\n      enumerable: false,                                                                                   // 7\n      value: testObj                                                                                       // 8\n    });                                                                                                    // 9\n                                                                                                           // 10\n    for (var k in testObj) {                                                                               // 11\n      if (k === testPropName) {                                                                            // 12\n        return false;                                                                                      // 13\n      }                                                                                                    // 14\n    }                                                                                                      // 15\n  } catch (e) {                                                                                            // 16\n    return false;                                                                                          // 17\n  }                                                                                                        // 18\n                                                                                                           // 19\n  return testObj[testPropName] === testObj;                                                                // 20\n}                                                                                                          // 21\n                                                                                                           // 22\nfunction sanitizeEasy(value) {                                                                             // 23\n  return value;                                                                                            // 24\n}                                                                                                          // 25\n                                                                                                           // 26\nfunction sanitizeHard(obj) {                                                                               // 27\n  if (Array.isArray(obj)) {                                                                                // 28\n    var newObj = {};                                                                                       // 29\n    var keys = Object.keys(obj);                                                                           // 30\n    var keyCount = keys.length;                                                                            // 31\n    for (var i = 0; i < keyCount; ++i) {                                                                   // 32\n      var key = keys[i];                                                                                   // 33\n      newObj[key] = obj[key];                                                                              // 34\n    }                                                                                                      // 35\n    return newObj;                                                                                         // 36\n  }                                                                                                        // 37\n                                                                                                           // 38\n  return obj;                                                                                              // 39\n}                                                                                                          // 40\n                                                                                                           // 41\nmeteorBabelHelpers = module.exports = {                                                                    // 42\n  // Meteor-specific runtime helper for wrapping the object of for-in                                      // 43\n  // loops, so that inherited Array methods defined by es5-shim can be                                     // 44\n  // ignored in browsers where they cannot be defined as non-enumerable.                                   // 45\n  sanitizeForInObject: canDefineNonEnumerableProperties()                                                  // 46\n    ? sanitizeEasy                                                                                         // 47\n    : sanitizeHard,                                                                                        // 48\n                                                                                                           // 49\n  // Exposed so that we can test sanitizeForInObject in environments that                                  // 50\n  // support defining non-enumerable properties.                                                           // 51\n  _sanitizeForInObjectHard: sanitizeHard                                                                   // 52\n};                                                                                                         // 53\n                                                                                                           // 54\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"regenerator\":{\"runtime-module.js\":[\"./runtime\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator/runtime-module.js                            //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// This method of obtaining a reference to the global object needs to be                                   // 1\n// kept identical to the way it is obtained in runtime.js                                                  // 2\nvar g =                                                                                                    // 3\n  typeof global === \"object\" ? global :                                                                    // 4\n  typeof window === \"object\" ? window :                                                                    // 5\n  typeof self === \"object\" ? self : this;                                                                  // 6\n                                                                                                           // 7\n// Use `getOwnPropertyNames` because not all browsers support calling                                      // 8\n// `hasOwnProperty` on the global `self` object in a worker. See #183.                                     // 9\nvar hadRuntime = g.regeneratorRuntime &&                                                                   // 10\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;                                        // 11\n                                                                                                           // 12\n// Save the old regeneratorRuntime in case it needs to be restored later.                                  // 13\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;                                                       // 14\n                                                                                                           // 15\n// Force reevalutation of runtime.js.                                                                      // 16\ng.regeneratorRuntime = undefined;                                                                          // 17\n                                                                                                           // 18\nmodule.exports = require(\"./runtime\");                                                                     // 19\n                                                                                                           // 20\nif (hadRuntime) {                                                                                          // 21\n  // Restore the original runtime.                                                                         // 22\n  g.regeneratorRuntime = oldRuntime;                                                                       // 23\n} else {                                                                                                   // 24\n  // Remove the global property added by runtime.js.                                                       // 25\n  try {                                                                                                    // 26\n    delete g.regeneratorRuntime;                                                                           // 27\n  } catch(e) {                                                                                             // 28\n    g.regeneratorRuntime = undefined;                                                                      // 29\n  }                                                                                                        // 30\n}                                                                                                          // 31\n                                                                                                           // 32\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"runtime.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator/runtime.js                                   //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n/**                                                                                                        // 1\n * Copyright (c) 2014, Facebook, Inc.                                                                      // 2\n * All rights reserved.                                                                                    // 3\n *                                                                                                         // 4\n * This source code is licensed under the BSD-style license found in the                                   // 5\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An                                     // 6\n * additional grant of patent rights can be found in the PATENTS file in                                   // 7\n * the same directory.                                                                                     // 8\n */                                                                                                        // 9\n                                                                                                           // 10\n!(function(global) {                                                                                       // 11\n  \"use strict\";                                                                                            // 12\n                                                                                                           // 13\n  var hasOwn = Object.prototype.hasOwnProperty;                                                            // 14\n  var undefined; // More compressible than void 0.                                                         // 15\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};                                                // 16\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";                                                   // 17\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";                                          // 18\n                                                                                                           // 19\n  var inModule = typeof module === \"object\";                                                               // 20\n  var runtime = global.regeneratorRuntime;                                                                 // 21\n  if (runtime) {                                                                                           // 22\n    if (inModule) {                                                                                        // 23\n      // If regeneratorRuntime is defined globally and we're in a module,                                  // 24\n      // make the exports object identical to regeneratorRuntime.                                          // 25\n      module.exports = runtime;                                                                            // 26\n    }                                                                                                      // 27\n    // Don't bother evaluating the rest of this file if the runtime was                                    // 28\n    // already defined globally.                                                                           // 29\n    return;                                                                                                // 30\n  }                                                                                                        // 31\n                                                                                                           // 32\n  // Define the runtime globally (as expected by generated code) as either                                 // 33\n  // module.exports (if we're in a module) or a new, empty object.                                         // 34\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};                                    // 35\n                                                                                                           // 36\n  function wrap(innerFn, outerFn, self, tryLocsList) {                                                     // 37\n    // If outerFn provided, then outerFn.prototype instanceof Generator.                                   // 38\n    var generator = Object.create((outerFn || Generator).prototype);                                       // 39\n    var context = new Context(tryLocsList || []);                                                          // 40\n                                                                                                           // 41\n    // The ._invoke method unifies the implementations of the .next,                                       // 42\n    // .throw, and .return methods.                                                                        // 43\n    generator._invoke = makeInvokeMethod(innerFn, self, context);                                          // 44\n                                                                                                           // 45\n    return generator;                                                                                      // 46\n  }                                                                                                        // 47\n  runtime.wrap = wrap;                                                                                     // 48\n                                                                                                           // 49\n  // Try/catch helper to minimize deoptimizations. Returns a completion                                    // 50\n  // record like context.tryEntries[i].completion. This interface could                                    // 51\n  // have been (and was previously) designed to take a closure to be                                       // 52\n  // invoked without arguments, but in all the cases we care about we                                      // 53\n  // already have an existing method we want to call, so there's no need                                   // 54\n  // to create a new function object. We can even get away with assuming                                   // 55\n  // the method takes exactly one argument, since that happens to be true                                  // 56\n  // in every case, so we don't have to touch the arguments object. The                                    // 57\n  // only additional allocation required is the completion record, which                                   // 58\n  // has a stable shape and so hopefully should be cheap to allocate.                                      // 59\n  function tryCatch(fn, obj, arg) {                                                                        // 60\n    try {                                                                                                  // 61\n      return { type: \"normal\", arg: fn.call(obj, arg) };                                                   // 62\n    } catch (err) {                                                                                        // 63\n      return { type: \"throw\", arg: err };                                                                  // 64\n    }                                                                                                      // 65\n  }                                                                                                        // 66\n                                                                                                           // 67\n  var GenStateSuspendedStart = \"suspendedStart\";                                                           // 68\n  var GenStateSuspendedYield = \"suspendedYield\";                                                           // 69\n  var GenStateExecuting = \"executing\";                                                                     // 70\n  var GenStateCompleted = \"completed\";                                                                     // 71\n                                                                                                           // 72\n  // Returning this object from the innerFn has the same effect as                                         // 73\n  // breaking out of the dispatch switch statement.                                                        // 74\n  var ContinueSentinel = {};                                                                               // 75\n                                                                                                           // 76\n  // Dummy constructor functions that we use as the .constructor and                                       // 77\n  // .constructor.prototype properties for functions that return Generator                                 // 78\n  // objects. For full spec compliance, you may wish to configure your                                     // 79\n  // minifier not to mangle the names of these two functions.                                              // 80\n  function Generator() {}                                                                                  // 81\n  function GeneratorFunction() {}                                                                          // 82\n  function GeneratorFunctionPrototype() {}                                                                 // 83\n                                                                                                           // 84\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;                                     // 85\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;                               // 86\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;                                              // 87\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";     // 88\n                                                                                                           // 89\n  // Helper for defining the .next, .throw, and .return methods of the                                     // 90\n  // Iterator interface in terms of a single ._invoke method.                                              // 91\n  function defineIteratorMethods(prototype) {                                                              // 92\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {                                                 // 93\n      prototype[method] = function(arg) {                                                                  // 94\n        return this._invoke(method, arg);                                                                  // 95\n      };                                                                                                   // 96\n    });                                                                                                    // 97\n  }                                                                                                        // 98\n                                                                                                           // 99\n  runtime.isGeneratorFunction = function(genFun) {                                                         // 100\n    var ctor = typeof genFun === \"function\" && genFun.constructor;                                         // 101\n    return ctor                                                                                            // 102\n      ? ctor === GeneratorFunction ||                                                                      // 103\n        // For the native GeneratorFunction constructor, the best we can                                   // 104\n        // do is to check its .name property.                                                              // 105\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"                                            // 106\n      : false;                                                                                             // 107\n  };                                                                                                       // 108\n                                                                                                           // 109\n  runtime.mark = function(genFun) {                                                                        // 110\n    if (Object.setPrototypeOf) {                                                                           // 111\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);                                           // 112\n    } else {                                                                                               // 113\n      genFun.__proto__ = GeneratorFunctionPrototype;                                                       // 114\n      if (!(toStringTagSymbol in genFun)) {                                                                // 115\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";                                                   // 116\n      }                                                                                                    // 117\n    }                                                                                                      // 118\n    genFun.prototype = Object.create(Gp);                                                                  // 119\n    return genFun;                                                                                         // 120\n  };                                                                                                       // 121\n                                                                                                           // 122\n  // Within the body of any async function, `await x` is transformed to                                    // 123\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test                                     // 124\n  // `value instanceof AwaitArgument` to determine if the yielded value is                                 // 125\n  // meant to be awaited. Some may consider the name of this method too                                    // 126\n  // cutesy, but they are curmudgeons.                                                                     // 127\n  runtime.awrap = function(arg) {                                                                          // 128\n    return new AwaitArgument(arg);                                                                         // 129\n  };                                                                                                       // 130\n                                                                                                           // 131\n  function AwaitArgument(arg) {                                                                            // 132\n    this.arg = arg;                                                                                        // 133\n  }                                                                                                        // 134\n                                                                                                           // 135\n  function AsyncIterator(generator) {                                                                      // 136\n    function invoke(method, arg, resolve, reject) {                                                        // 137\n      var record = tryCatch(generator[method], generator, arg);                                            // 138\n      if (record.type === \"throw\") {                                                                       // 139\n        reject(record.arg);                                                                                // 140\n      } else {                                                                                             // 141\n        var result = record.arg;                                                                           // 142\n        var value = result.value;                                                                          // 143\n        if (value instanceof AwaitArgument) {                                                              // 144\n          return Promise.resolve(value.arg).then(function(value) {                                         // 145\n            invoke(\"next\", value, resolve, reject);                                                        // 146\n          }, function(err) {                                                                               // 147\n            invoke(\"throw\", err, resolve, reject);                                                         // 148\n          });                                                                                              // 149\n        }                                                                                                  // 150\n                                                                                                           // 151\n        return Promise.resolve(value).then(function(unwrapped) {                                           // 152\n          // When a yielded Promise is resolved, its final value becomes                                   // 153\n          // the .value of the Promise<{value,done}> result for the                                        // 154\n          // current iteration. If the Promise is rejected, however, the                                   // 155\n          // result for this iteration will be rejected with the same                                      // 156\n          // reason. Note that rejections of yielded Promises are not                                      // 157\n          // thrown back into the generator function, as is the case                                       // 158\n          // when an awaited Promise is rejected. This difference in                                       // 159\n          // behavior between yield and await is important, because it                                     // 160\n          // allows the consumer to decide what to do with the yielded                                     // 161\n          // rejection (swallow it and continue, manually .throw it back                                   // 162\n          // into the generator, abandon iteration, whatever). With                                        // 163\n          // await, by contrast, there is no opportunity to examine the                                    // 164\n          // rejection reason outside the generator function, so the                                       // 165\n          // only option is to throw it from the await expression, and                                     // 166\n          // let the generator function handle the exception.                                              // 167\n          result.value = unwrapped;                                                                        // 168\n          resolve(result);                                                                                 // 169\n        }, reject);                                                                                        // 170\n      }                                                                                                    // 171\n    }                                                                                                      // 172\n                                                                                                           // 173\n    if (typeof process === \"object\" && process.domain) {                                                   // 174\n      invoke = process.domain.bind(invoke);                                                                // 175\n    }                                                                                                      // 176\n                                                                                                           // 177\n    var previousPromise;                                                                                   // 178\n                                                                                                           // 179\n    function enqueue(method, arg) {                                                                        // 180\n      function callInvokeWithMethodAndArg() {                                                              // 181\n        return new Promise(function(resolve, reject) {                                                     // 182\n          invoke(method, arg, resolve, reject);                                                            // 183\n        });                                                                                                // 184\n      }                                                                                                    // 185\n                                                                                                           // 186\n      return previousPromise =                                                                             // 187\n        // If enqueue has been called before, then we want to wait until                                   // 188\n        // all previous Promises have been resolved before calling invoke,                                 // 189\n        // so that results are always delivered in the correct order. If                                   // 190\n        // enqueue has not been called before, then it is important to                                     // 191\n        // call invoke immediately, without waiting on a callback to fire,                                 // 192\n        // so that the async generator function has the opportunity to do                                  // 193\n        // any necessary setup in a predictable way. This predictability                                   // 194\n        // is why the Promise constructor synchronously invokes its                                        // 195\n        // executor callback, and why async functions synchronously                                        // 196\n        // execute code before the first await. Since we implement simple                                  // 197\n        // async functions in terms of async generators, it is especially                                  // 198\n        // important to get this right, even though it requires care.                                      // 199\n        previousPromise ? previousPromise.then(                                                            // 200\n          callInvokeWithMethodAndArg,                                                                      // 201\n          // Avoid propagating failures to Promises returned by later                                      // 202\n          // invocations of the iterator.                                                                  // 203\n          callInvokeWithMethodAndArg                                                                       // 204\n        ) : callInvokeWithMethodAndArg();                                                                  // 205\n    }                                                                                                      // 206\n                                                                                                           // 207\n    // Define the unified helper method that is used to implement .next,                                   // 208\n    // .throw, and .return (see defineIteratorMethods).                                                    // 209\n    this._invoke = enqueue;                                                                                // 210\n  }                                                                                                        // 211\n                                                                                                           // 212\n  defineIteratorMethods(AsyncIterator.prototype);                                                          // 213\n                                                                                                           // 214\n  // Note that simple async functions are implemented on top of                                            // 215\n  // AsyncIterator objects; they just return a Promise for the value of                                    // 216\n  // the final result produced by the iterator.                                                            // 217\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {                                          // 218\n    var iter = new AsyncIterator(                                                                          // 219\n      wrap(innerFn, outerFn, self, tryLocsList)                                                            // 220\n    );                                                                                                     // 221\n                                                                                                           // 222\n    return runtime.isGeneratorFunction(outerFn)                                                            // 223\n      ? iter // If outerFn is a generator, return the full iterator.                                       // 224\n      : iter.next().then(function(result) {                                                                // 225\n          return result.done ? result.value : iter.next();                                                 // 226\n        });                                                                                                // 227\n  };                                                                                                       // 228\n                                                                                                           // 229\n  function makeInvokeMethod(innerFn, self, context) {                                                      // 230\n    var state = GenStateSuspendedStart;                                                                    // 231\n                                                                                                           // 232\n    return function invoke(method, arg) {                                                                  // 233\n      if (state === GenStateExecuting) {                                                                   // 234\n        throw new Error(\"Generator is already running\");                                                   // 235\n      }                                                                                                    // 236\n                                                                                                           // 237\n      if (state === GenStateCompleted) {                                                                   // 238\n        if (method === \"throw\") {                                                                          // 239\n          throw arg;                                                                                       // 240\n        }                                                                                                  // 241\n                                                                                                           // 242\n        // Be forgiving, per 25.3.3.3.3 of the spec:                                                       // 243\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume                       // 244\n        return doneResult();                                                                               // 245\n      }                                                                                                    // 246\n                                                                                                           // 247\n      while (true) {                                                                                       // 248\n        var delegate = context.delegate;                                                                   // 249\n        if (delegate) {                                                                                    // 250\n          if (method === \"return\" ||                                                                       // 251\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {                           // 252\n            // A return or throw (when the delegate iterator has no throw                                  // 253\n            // method) always terminates the yield* loop.                                                  // 254\n            context.delegate = null;                                                                       // 255\n                                                                                                           // 256\n            // If the delegate iterator has a return method, give it a                                     // 257\n            // chance to clean up.                                                                         // 258\n            var returnMethod = delegate.iterator[\"return\"];                                                // 259\n            if (returnMethod) {                                                                            // 260\n              var record = tryCatch(returnMethod, delegate.iterator, arg);                                 // 261\n              if (record.type === \"throw\") {                                                               // 262\n                // If the return method threw an exception, let that                                       // 263\n                // exception prevail over the original return or throw.                                    // 264\n                method = \"throw\";                                                                          // 265\n                arg = record.arg;                                                                          // 266\n                continue;                                                                                  // 267\n              }                                                                                            // 268\n            }                                                                                              // 269\n                                                                                                           // 270\n            if (method === \"return\") {                                                                     // 271\n              // Continue with the outer return, now that the delegate                                     // 272\n              // iterator has been terminated.                                                             // 273\n              continue;                                                                                    // 274\n            }                                                                                              // 275\n          }                                                                                                // 276\n                                                                                                           // 277\n          var record = tryCatch(                                                                           // 278\n            delegate.iterator[method],                                                                     // 279\n            delegate.iterator,                                                                             // 280\n            arg                                                                                            // 281\n          );                                                                                               // 282\n                                                                                                           // 283\n          if (record.type === \"throw\") {                                                                   // 284\n            context.delegate = null;                                                                       // 285\n                                                                                                           // 286\n            // Like returning generator.throw(uncaught), but without the                                   // 287\n            // overhead of an extra function call.                                                         // 288\n            method = \"throw\";                                                                              // 289\n            arg = record.arg;                                                                              // 290\n            continue;                                                                                      // 291\n          }                                                                                                // 292\n                                                                                                           // 293\n          // Delegate generator ran and handled its own exceptions so                                      // 294\n          // regardless of what the method was, we continue as if it is                                    // 295\n          // \"next\" with an undefined arg.                                                                 // 296\n          method = \"next\";                                                                                 // 297\n          arg = undefined;                                                                                 // 298\n                                                                                                           // 299\n          var info = record.arg;                                                                           // 300\n          if (info.done) {                                                                                 // 301\n            context[delegate.resultName] = info.value;                                                     // 302\n            context.next = delegate.nextLoc;                                                               // 303\n          } else {                                                                                         // 304\n            state = GenStateSuspendedYield;                                                                // 305\n            return info;                                                                                   // 306\n          }                                                                                                // 307\n                                                                                                           // 308\n          context.delegate = null;                                                                         // 309\n        }                                                                                                  // 310\n                                                                                                           // 311\n        if (method === \"next\") {                                                                           // 312\n          if (state === GenStateSuspendedYield) {                                                          // 313\n            context.sent = arg;                                                                            // 314\n          } else {                                                                                         // 315\n            context.sent = undefined;                                                                      // 316\n          }                                                                                                // 317\n                                                                                                           // 318\n        } else if (method === \"throw\") {                                                                   // 319\n          if (state === GenStateSuspendedStart) {                                                          // 320\n            state = GenStateCompleted;                                                                     // 321\n            throw arg;                                                                                     // 322\n          }                                                                                                // 323\n                                                                                                           // 324\n          if (context.dispatchException(arg)) {                                                            // 325\n            // If the dispatched exception was caught by a catch block,                                    // 326\n            // then let that catch block handle the exception normally.                                    // 327\n            method = \"next\";                                                                               // 328\n            arg = undefined;                                                                               // 329\n          }                                                                                                // 330\n                                                                                                           // 331\n        } else if (method === \"return\") {                                                                  // 332\n          context.abrupt(\"return\", arg);                                                                   // 333\n        }                                                                                                  // 334\n                                                                                                           // 335\n        state = GenStateExecuting;                                                                         // 336\n                                                                                                           // 337\n        var record = tryCatch(innerFn, self, context);                                                     // 338\n        if (record.type === \"normal\") {                                                                    // 339\n          // If an exception is thrown from innerFn, we leave state ===                                    // 340\n          // GenStateExecuting and loop back for another invocation.                                       // 341\n          state = context.done                                                                             // 342\n            ? GenStateCompleted                                                                            // 343\n            : GenStateSuspendedYield;                                                                      // 344\n                                                                                                           // 345\n          var info = {                                                                                     // 346\n            value: record.arg,                                                                             // 347\n            done: context.done                                                                             // 348\n          };                                                                                               // 349\n                                                                                                           // 350\n          if (record.arg === ContinueSentinel) {                                                           // 351\n            if (context.delegate && method === \"next\") {                                                   // 352\n              // Deliberately forget the last sent value so that we don't                                  // 353\n              // accidentally pass it on to the delegate.                                                  // 354\n              arg = undefined;                                                                             // 355\n            }                                                                                              // 356\n          } else {                                                                                         // 357\n            return info;                                                                                   // 358\n          }                                                                                                // 359\n                                                                                                           // 360\n        } else if (record.type === \"throw\") {                                                              // 361\n          state = GenStateCompleted;                                                                       // 362\n          // Dispatch the exception by looping back around to the                                          // 363\n          // context.dispatchException(arg) call above.                                                    // 364\n          method = \"throw\";                                                                                // 365\n          arg = record.arg;                                                                                // 366\n        }                                                                                                  // 367\n      }                                                                                                    // 368\n    };                                                                                                     // 369\n  }                                                                                                        // 370\n                                                                                                           // 371\n  // Define Generator.prototype.{next,throw,return} in terms of the                                        // 372\n  // unified ._invoke helper method.                                                                       // 373\n  defineIteratorMethods(Gp);                                                                               // 374\n                                                                                                           // 375\n  Gp[iteratorSymbol] = function() {                                                                        // 376\n    return this;                                                                                           // 377\n  };                                                                                                       // 378\n                                                                                                           // 379\n  Gp[toStringTagSymbol] = \"Generator\";                                                                     // 380\n                                                                                                           // 381\n  Gp.toString = function() {                                                                               // 382\n    return \"[object Generator]\";                                                                           // 383\n  };                                                                                                       // 384\n                                                                                                           // 385\n  function pushTryEntry(locs) {                                                                            // 386\n    var entry = { tryLoc: locs[0] };                                                                       // 387\n                                                                                                           // 388\n    if (1 in locs) {                                                                                       // 389\n      entry.catchLoc = locs[1];                                                                            // 390\n    }                                                                                                      // 391\n                                                                                                           // 392\n    if (2 in locs) {                                                                                       // 393\n      entry.finallyLoc = locs[2];                                                                          // 394\n      entry.afterLoc = locs[3];                                                                            // 395\n    }                                                                                                      // 396\n                                                                                                           // 397\n    this.tryEntries.push(entry);                                                                           // 398\n  }                                                                                                        // 399\n                                                                                                           // 400\n  function resetTryEntry(entry) {                                                                          // 401\n    var record = entry.completion || {};                                                                   // 402\n    record.type = \"normal\";                                                                                // 403\n    delete record.arg;                                                                                     // 404\n    entry.completion = record;                                                                             // 405\n  }                                                                                                        // 406\n                                                                                                           // 407\n  function Context(tryLocsList) {                                                                          // 408\n    // The root entry object (effectively a try statement without a catch                                  // 409\n    // or a finally block) gives us a place to store values thrown from                                    // 410\n    // locations where there is no enclosing try statement.                                                // 411\n    this.tryEntries = [{ tryLoc: \"root\" }];                                                                // 412\n    tryLocsList.forEach(pushTryEntry, this);                                                               // 413\n    this.reset(true);                                                                                      // 414\n  }                                                                                                        // 415\n                                                                                                           // 416\n  runtime.keys = function(object) {                                                                        // 417\n    var keys = [];                                                                                         // 418\n    for (var key in object) {                                                                              // 419\n      keys.push(key);                                                                                      // 420\n    }                                                                                                      // 421\n    keys.reverse();                                                                                        // 422\n                                                                                                           // 423\n    // Rather than returning an object with a next method, we keep                                         // 424\n    // things simple and return the next function itself.                                                  // 425\n    return function next() {                                                                               // 426\n      while (keys.length) {                                                                                // 427\n        var key = keys.pop();                                                                              // 428\n        if (key in object) {                                                                               // 429\n          next.value = key;                                                                                // 430\n          next.done = false;                                                                               // 431\n          return next;                                                                                     // 432\n        }                                                                                                  // 433\n      }                                                                                                    // 434\n                                                                                                           // 435\n      // To avoid creating an additional object, we just hang the .value                                   // 436\n      // and .done properties off the next function object itself. This                                    // 437\n      // also ensures that the minifier will not anonymize the function.                                   // 438\n      next.done = true;                                                                                    // 439\n      return next;                                                                                         // 440\n    };                                                                                                     // 441\n  };                                                                                                       // 442\n                                                                                                           // 443\n  function values(iterable) {                                                                              // 444\n    if (iterable) {                                                                                        // 445\n      var iteratorMethod = iterable[iteratorSymbol];                                                       // 446\n      if (iteratorMethod) {                                                                                // 447\n        return iteratorMethod.call(iterable);                                                              // 448\n      }                                                                                                    // 449\n                                                                                                           // 450\n      if (typeof iterable.next === \"function\") {                                                           // 451\n        return iterable;                                                                                   // 452\n      }                                                                                                    // 453\n                                                                                                           // 454\n      if (!isNaN(iterable.length)) {                                                                       // 455\n        var i = -1, next = function next() {                                                               // 456\n          while (++i < iterable.length) {                                                                  // 457\n            if (hasOwn.call(iterable, i)) {                                                                // 458\n              next.value = iterable[i];                                                                    // 459\n              next.done = false;                                                                           // 460\n              return next;                                                                                 // 461\n            }                                                                                              // 462\n          }                                                                                                // 463\n                                                                                                           // 464\n          next.value = undefined;                                                                          // 465\n          next.done = true;                                                                                // 466\n                                                                                                           // 467\n          return next;                                                                                     // 468\n        };                                                                                                 // 469\n                                                                                                           // 470\n        return next.next = next;                                                                           // 471\n      }                                                                                                    // 472\n    }                                                                                                      // 473\n                                                                                                           // 474\n    // Return an iterator with no values.                                                                  // 475\n    return { next: doneResult };                                                                           // 476\n  }                                                                                                        // 477\n  runtime.values = values;                                                                                 // 478\n                                                                                                           // 479\n  function doneResult() {                                                                                  // 480\n    return { value: undefined, done: true };                                                               // 481\n  }                                                                                                        // 482\n                                                                                                           // 483\n  Context.prototype = {                                                                                    // 484\n    constructor: Context,                                                                                  // 485\n                                                                                                           // 486\n    reset: function(skipTempReset) {                                                                       // 487\n      this.prev = 0;                                                                                       // 488\n      this.next = 0;                                                                                       // 489\n      this.sent = undefined;                                                                               // 490\n      this.done = false;                                                                                   // 491\n      this.delegate = null;                                                                                // 492\n                                                                                                           // 493\n      this.tryEntries.forEach(resetTryEntry);                                                              // 494\n                                                                                                           // 495\n      if (!skipTempReset) {                                                                                // 496\n        for (var name in this) {                                                                           // 497\n          // Not sure about the optimal order of these conditions:                                         // 498\n          if (name.charAt(0) === \"t\" &&                                                                    // 499\n              hasOwn.call(this, name) &&                                                                   // 500\n              !isNaN(+name.slice(1))) {                                                                    // 501\n            this[name] = undefined;                                                                        // 502\n          }                                                                                                // 503\n        }                                                                                                  // 504\n      }                                                                                                    // 505\n    },                                                                                                     // 506\n                                                                                                           // 507\n    stop: function() {                                                                                     // 508\n      this.done = true;                                                                                    // 509\n                                                                                                           // 510\n      var rootEntry = this.tryEntries[0];                                                                  // 511\n      var rootRecord = rootEntry.completion;                                                               // 512\n      if (rootRecord.type === \"throw\") {                                                                   // 513\n        throw rootRecord.arg;                                                                              // 514\n      }                                                                                                    // 515\n                                                                                                           // 516\n      return this.rval;                                                                                    // 517\n    },                                                                                                     // 518\n                                                                                                           // 519\n    dispatchException: function(exception) {                                                               // 520\n      if (this.done) {                                                                                     // 521\n        throw exception;                                                                                   // 522\n      }                                                                                                    // 523\n                                                                                                           // 524\n      var context = this;                                                                                  // 525\n      function handle(loc, caught) {                                                                       // 526\n        record.type = \"throw\";                                                                             // 527\n        record.arg = exception;                                                                            // 528\n        context.next = loc;                                                                                // 529\n        return !!caught;                                                                                   // 530\n      }                                                                                                    // 531\n                                                                                                           // 532\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 533\n        var entry = this.tryEntries[i];                                                                    // 534\n        var record = entry.completion;                                                                     // 535\n                                                                                                           // 536\n        if (entry.tryLoc === \"root\") {                                                                     // 537\n          // Exception thrown outside of any try block that could handle                                   // 538\n          // it, so set the completion value of the entire function to                                     // 539\n          // throw the exception.                                                                          // 540\n          return handle(\"end\");                                                                            // 541\n        }                                                                                                  // 542\n                                                                                                           // 543\n        if (entry.tryLoc <= this.prev) {                                                                   // 544\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");                                                   // 545\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");                                               // 546\n                                                                                                           // 547\n          if (hasCatch && hasFinally) {                                                                    // 548\n            if (this.prev < entry.catchLoc) {                                                              // 549\n              return handle(entry.catchLoc, true);                                                         // 550\n            } else if (this.prev < entry.finallyLoc) {                                                     // 551\n              return handle(entry.finallyLoc);                                                             // 552\n            }                                                                                              // 553\n                                                                                                           // 554\n          } else if (hasCatch) {                                                                           // 555\n            if (this.prev < entry.catchLoc) {                                                              // 556\n              return handle(entry.catchLoc, true);                                                         // 557\n            }                                                                                              // 558\n                                                                                                           // 559\n          } else if (hasFinally) {                                                                         // 560\n            if (this.prev < entry.finallyLoc) {                                                            // 561\n              return handle(entry.finallyLoc);                                                             // 562\n            }                                                                                              // 563\n                                                                                                           // 564\n          } else {                                                                                         // 565\n            throw new Error(\"try statement without catch or finally\");                                     // 566\n          }                                                                                                // 567\n        }                                                                                                  // 568\n      }                                                                                                    // 569\n    },                                                                                                     // 570\n                                                                                                           // 571\n    abrupt: function(type, arg) {                                                                          // 572\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 573\n        var entry = this.tryEntries[i];                                                                    // 574\n        if (entry.tryLoc <= this.prev &&                                                                   // 575\n            hasOwn.call(entry, \"finallyLoc\") &&                                                            // 576\n            this.prev < entry.finallyLoc) {                                                                // 577\n          var finallyEntry = entry;                                                                        // 578\n          break;                                                                                           // 579\n        }                                                                                                  // 580\n      }                                                                                                    // 581\n                                                                                                           // 582\n      if (finallyEntry &&                                                                                  // 583\n          (type === \"break\" ||                                                                             // 584\n           type === \"continue\") &&                                                                         // 585\n          finallyEntry.tryLoc <= arg &&                                                                    // 586\n          arg <= finallyEntry.finallyLoc) {                                                                // 587\n        // Ignore the finally entry if control is not jumping to a                                         // 588\n        // location outside the try/catch block.                                                           // 589\n        finallyEntry = null;                                                                               // 590\n      }                                                                                                    // 591\n                                                                                                           // 592\n      var record = finallyEntry ? finallyEntry.completion : {};                                            // 593\n      record.type = type;                                                                                  // 594\n      record.arg = arg;                                                                                    // 595\n                                                                                                           // 596\n      if (finallyEntry) {                                                                                  // 597\n        this.next = finallyEntry.finallyLoc;                                                               // 598\n      } else {                                                                                             // 599\n        this.complete(record);                                                                             // 600\n      }                                                                                                    // 601\n                                                                                                           // 602\n      return ContinueSentinel;                                                                             // 603\n    },                                                                                                     // 604\n                                                                                                           // 605\n    complete: function(record, afterLoc) {                                                                 // 606\n      if (record.type === \"throw\") {                                                                       // 607\n        throw record.arg;                                                                                  // 608\n      }                                                                                                    // 609\n                                                                                                           // 610\n      if (record.type === \"break\" ||                                                                       // 611\n          record.type === \"continue\") {                                                                    // 612\n        this.next = record.arg;                                                                            // 613\n      } else if (record.type === \"return\") {                                                               // 614\n        this.rval = record.arg;                                                                            // 615\n        this.next = \"end\";                                                                                 // 616\n      } else if (record.type === \"normal\" && afterLoc) {                                                   // 617\n        this.next = afterLoc;                                                                              // 618\n      }                                                                                                    // 619\n    },                                                                                                     // 620\n                                                                                                           // 621\n    finish: function(finallyLoc) {                                                                         // 622\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 623\n        var entry = this.tryEntries[i];                                                                    // 624\n        if (entry.finallyLoc === finallyLoc) {                                                             // 625\n          this.complete(entry.completion, entry.afterLoc);                                                 // 626\n          resetTryEntry(entry);                                                                            // 627\n          return ContinueSentinel;                                                                         // 628\n        }                                                                                                  // 629\n      }                                                                                                    // 630\n    },                                                                                                     // 631\n                                                                                                           // 632\n    \"catch\": function(tryLoc) {                                                                            // 633\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 634\n        var entry = this.tryEntries[i];                                                                    // 635\n        if (entry.tryLoc === tryLoc) {                                                                     // 636\n          var record = entry.completion;                                                                   // 637\n          if (record.type === \"throw\") {                                                                   // 638\n            var thrown = record.arg;                                                                       // 639\n            resetTryEntry(entry);                                                                          // 640\n          }                                                                                                // 641\n          return thrown;                                                                                   // 642\n        }                                                                                                  // 643\n      }                                                                                                    // 644\n                                                                                                           // 645\n      // The context.catch method must only be called with a location                                      // 646\n      // argument that corresponds to a known catch block.                                                 // 647\n      throw new Error(\"illegal catch attempt\");                                                            // 648\n    },                                                                                                     // 649\n                                                                                                           // 650\n    delegateYield: function(iterable, resultName, nextLoc) {                                               // 651\n      this.delegate = {                                                                                    // 652\n        iterator: values(iterable),                                                                        // 653\n        resultName: resultName,                                                                            // 654\n        nextLoc: nextLoc                                                                                   // 655\n      };                                                                                                   // 656\n                                                                                                           // 657\n      return ContinueSentinel;                                                                             // 658\n    }                                                                                                      // 659\n  };                                                                                                       // 660\n})(                                                                                                        // 661\n  // Among the various tricks for obtaining a reference to the global                                      // 662\n  // object, this seems to be the most reliable technique that does not                                    // 663\n  // use indirect eval (which violates Content Security Policy).                                           // 664\n  typeof global === \"object\" ? global :                                                                    // 665\n  typeof window === \"object\" ? window :                                                                    // 666\n  typeof self === \"object\" ? self : this                                                                   // 667\n);                                                                                                         // 668\n                                                                                                           // 669\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/babel-runtime/babel-runtime.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['babel-runtime'] = {}, {\n  meteorBabelHelpers: meteorBabelHelpers\n});\n\n})();\n","servePath":"/packages/babel-runtime.js","sourceMap":{"version":3,"sources":["/packages/babel-runtime/babel-runtime.js","../npm/node_modules/meteor-babel-helpers/package.json","node_modules/meteor/babel-runtime/node_modules/meteor-babel-helpers/index.js","node_modules/meteor/babel-runtime/node_modules/regenerator/runtime-module.js","node_modules/meteor/babel-runtime/node_modules/regenerator/runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH;;;;;;;;;;;AC5XA;AACA;AACA;AACA,+G;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gH;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gH;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH","file":"/packages/babel-runtime.js","sourcesContent":["var hasOwn = Object.prototype.hasOwnProperty;\nvar S = typeof Symbol === \"function\" ? Symbol : {};\nvar iteratorSymbol = S.iterator || \"@@iterator\";\n\nmeteorBabelHelpers = require(\"meteor-babel-helpers\");\n\nvar BabelRuntime = {\n  // es6.templateLiterals\n  // Constructs the object passed to the tag function in a tagged\n  // template literal.\n  taggedTemplateLiteralLoose: function (strings, raw) {\n    // Babel's own version of this calls Object.freeze on `strings` and\n    // `strings.raw`, but it doesn't seem worth the compatibility and\n    // performance concerns.  If you're writing code against this helper,\n    // don't add properties to these objects.\n    strings.raw = raw;\n    return strings;\n  },\n\n  // es6.classes\n  // Checks that a class constructor is being called with `new`, and throws\n  // an error if it is not.\n  classCallCheck: function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  },\n\n  // es6.classes\n  inherits: function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    if (superClass) {\n      if (Object.create) {\n        // All but IE 8\n        subClass.prototype = Object.create(superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      } else {\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`\n        // is enumerable and shows up in the inspector unnecessarily.\n        // It's not an \"own\" property of any instance though.\n        //\n        // For correctness when writing code,\n        // don't enumerate all the own-and-inherited properties of an instance\n        // of a class and expect not to find `constructor` (but who does that?).\n        var F = function () {\n          this.constructor = subClass;\n        };\n        F.prototype = superClass.prototype;\n        subClass.prototype = new F();\n      }\n\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,\n      // but IE <=10 don't support `__proto__`, and in this case the difference\n      // would be detectable; code that works in modern browsers could easily\n      // fail on IE 8 if we ever used the `__proto__` trick.\n      //\n      // There's no perfect way to make static methods inherited if they are\n      // assigned after declaration of the classes.  The best we can do is\n      // to copy them.  In other words, when you write `class Foo\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future\n      // ones are not copied.\n      //\n      // For correctness when writing code, don't add static methods to a class\n      // after you subclass it.\n\n      // The ecmascript-runtime package provides adequate polyfills for\n      // all of these Object.* functions (and Array#forEach), and anyone\n      // using babel-runtime is almost certainly using it because of the\n      // ecmascript package, which also implies ecmascript-runtime.\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {\n        // This property descriptor dance preserves getter/setter behavior\n        // in browsers that support accessor properties (all except\n        // IE8). In IE8, the superClass can't have accessor properties\n        // anyway, so this code is still safe.\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);\n        if (descriptor && typeof descriptor === \"object\") {\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {\n            // If subClass already has a property by this name, then it\n            // would not be inherited, so it should not be copied. This\n            // notably excludes properties like .prototype and .name.\n            return;\n          }\n\n          Object.defineProperty(subClass, k, descriptor);\n        }\n      });\n    }\n  },\n\n  createClass: (function () {\n    var hasDefineProperty = false;\n    try {\n      // IE 8 has a broken Object.defineProperty, so feature-test by\n      // trying to call it.\n      Object.defineProperty({}, 'x', {});\n      hasDefineProperty = true;\n    } catch (e) {}\n\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (! hasDefineProperty) {\n        // e.g. `class Foo { get bar() {} }`.  If you try to use getters and\n        // setters in IE 8, you will get a big nasty error, with or without\n        // Babel.  I don't know of any other syntax features besides getters\n        // and setters that will trigger this error.\n        throw new Error(\n          \"Your browser does not support this type of class property.  \" +\n            \"For example, Internet Explorer 8 does not support getters and \" +\n            \"setters.\");\n      }\n\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })(),\n\n  \"typeof\": function (obj) {\n    return obj && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  },\n\n  possibleConstructorReturn: function (self, call) {\n    if (! self) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    var callType = typeof call;\n    if (call &&\n        callType === \"function\" ||\n        callType === \"object\") {\n      return call;\n    }\n\n    return self;\n  },\n\n  interopRequireDefault: function (obj) {\n    return obj && obj.__esModule ? obj : { 'default': obj };\n  },\n\n  interopRequireWildcard: function (obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (hasOwn.call(obj, key)) {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  },\n\n  interopExportWildcard: function (obj, defaults) {\n    var newObj = defaults({}, obj);\n    delete newObj[\"default\"];\n    return newObj;\n  },\n\n  defaults: function (obj, defaults) {\n    Object.getOwnPropertyNames(defaults).forEach(function (key) {\n      var desc = Object.getOwnPropertyDescriptor(defaults, key);\n      if (desc && desc.configurable && typeof obj[key] === \"undefined\") {\n        Object.defineProperty(obj, key, desc);\n      }\n    });\n\n    return obj;\n  },\n\n  // es7.objectRestSpread and react (JSX)\n  \"extends\": Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (hasOwn.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }),\n\n  // es6.destructuring\n  objectWithoutProperties: function (obj, keys) {\n    var target = {};\n    outer: for (var i in obj) {\n      if (! hasOwn.call(obj, i)) continue;\n      for (var j = 0; j < keys.length; j++) {\n        if (keys[j] === i) continue outer;\n      }\n      target[i] = obj[i];\n    }\n    return target;\n  },\n\n  // es6.destructuring\n  objectDestructuringEmpty: function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  },\n\n  // es6.spread\n  bind: Function.prototype.bind || (function () {\n    var isCallable = function (value) { return typeof value === 'function'; };\n    var $Object = Object;\n    var to_string = Object.prototype.toString;\n    var array_slice = Array.prototype.slice;\n    var array_concat = Array.prototype.concat;\n    var array_push = Array.prototype.push;\n    var max = Math.max;\n    var Empty = function Empty() {};\n\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.\n    return function bind(that) {\n      var target = this;\n      if (!isCallable(target)) {\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n      }\n\n      var args = array_slice.call(arguments, 1);\n\n      var bound;\n      var binder = function () {\n\n        if (this instanceof bound) {\n          var result = target.apply(\n            this,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n          if ($Object(result) === result) {\n            return result;\n          }\n          return this;\n        } else {\n          return target.apply(\n            that,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n        }\n      };\n\n      var boundLength = max(0, target.length - args.length);\n\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        array_push.call(boundArgs, '$' + i);\n      }\n\n      // Create a Function from source code so that it has the right `.length`.\n      // Probably not important for Babel.  This code violates CSPs that ban\n      // `eval`, but the browsers that need this polyfill don't have CSP!\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\n      if (target.prototype) {\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n\n      return bound;\n    };\n\n  })(),\n\n  toConsumableArray: function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = arr.length - 1, arr2 = Array(i + 1); i >= 0; --i) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    }\n\n    return Array.from(arr);\n  },\n\n  toArray: function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  },\n\n  slicedToArray: function (iterable, limit) {\n    if (Array.isArray(iterable)) {\n      return iterable;\n    }\n\n    if (iterable) {\n      var it = iterable[iteratorSymbol]();\n      var result = [];\n      var info;\n\n      if (typeof limit !== \"number\") {\n        limit = Infinity;\n      }\n\n      while (result.length < limit &&\n             ! (info = it.next()).done) {\n        result.push(info.value);\n      }\n\n      return result;\n    }\n\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance\"\n    );\n  },\n\n  slice: Array.prototype.slice\n};\n\n// Use meteorInstall to install all of the above helper functions within\n// node_modules/babel-runtime/helpers.\nObject.keys(BabelRuntime).forEach(function (helperName) {\n  var helpers = {};\n\n  helpers[helperName + \".js\"] = function (require, exports, module) {\n    module.exports = BabelRuntime[helperName];\n  };\n\n  meteorInstall({\n    node_modules: {\n      \"babel-runtime\": {\n        helpers: helpers\n      }\n    }\n  });\n});\n\n// Use meteorInstall to install the regenerator runtime at\n// node_modules/babel-runtime/regenerator.\nmeteorInstall({\n  node_modules: {\n    \"babel-runtime\": {\n      \"regenerator.js\": function (r, e, module) {\n        // Note that we use the require function provided to the\n        // babel-runtime.js file, not the one named 'r' above.\n        var runtime = require(\"regenerator/runtime-module\");\n\n        // If Promise.asyncApply is defined, use it to wrap calls to\n        // runtime.async so that the entire async function will run in its\n        // own Fiber, not just the code that comes after the first await.\n        if (typeof Promise === \"function\" &&\n            typeof Promise.asyncApply === \"function\") {\n          var realAsync = runtime.async;\n          runtime.async = function () {\n            return Promise.asyncApply(realAsync, runtime, arguments);\n          };\n        }\n\n        module.exports = runtime;\n      }\n    }\n  }\n});\n","exports.name = \"meteor-babel-helpers\";\nexports.version = \"0.0.3\";\nexports.main = \"index.js\";\n","function canDefineNonEnumerableProperties() {\n  var testObj = {};\n  var testPropName = \"t\";\n\n  try {\n    Object.defineProperty(testObj, testPropName, {\n      enumerable: false,\n      value: testObj\n    });\n\n    for (var k in testObj) {\n      if (k === testPropName) {\n        return false;\n      }\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return testObj[testPropName] === testObj;\n}\n\nfunction sanitizeEasy(value) {\n  return value;\n}\n\nfunction sanitizeHard(obj) {\n  if (Array.isArray(obj)) {\n    var newObj = {};\n    var keys = Object.keys(obj);\n    var keyCount = keys.length;\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      newObj[key] = obj[key];\n    }\n    return newObj;\n  }\n\n  return obj;\n}\n\nmeteorBabelHelpers = module.exports = {\n  // Meteor-specific runtime helper for wrapping the object of for-in\n  // loops, so that inherited Array methods defined by es5-shim can be\n  // ignored in browsers where they cannot be defined as non-enumerable.\n  sanitizeForInObject: canDefineNonEnumerableProperties()\n    ? sanitizeEasy\n    : sanitizeHard,\n\n  // Exposed so that we can test sanitizeForInObject in environments that\n  // support defining non-enumerable properties.\n  _sanitizeForInObjectHard: sanitizeHard\n};\n","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided, then outerFn.prototype instanceof Generator.\n    var generator = Object.create((outerFn || Generator).prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `value instanceof AwaitArgument` to determine if the yielded value is\n  // meant to be awaited. Some may consider the name of this method too\n  // cutesy, but they are curmudgeons.\n  runtime.awrap = function(arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value instanceof AwaitArgument) {\n          return Promise.resolve(value.arg).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            context.sent = undefined;\n          }\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n"]}}]