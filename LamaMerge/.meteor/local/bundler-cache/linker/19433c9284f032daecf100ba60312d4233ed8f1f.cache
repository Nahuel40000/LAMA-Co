[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar SimpleSchema = Package['aldeed:simple-schema'].SimpleSchema;\nvar MongoObject = Package['aldeed:simple-schema'].MongoObject;\nvar _ = Package.underscore._;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Mongo = Package.mongo.Mongo;\nvar EJSON = Package.ejson.EJSON;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////\n//                                                                   //\n// packages/aldeed_collection2/packages/aldeed_collection2.js        //\n//                                                                   //\n///////////////////////////////////////////////////////////////////////\n                                                                     //\n(function () {                                                       // 1\n                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/aldeed:collection2/collection2.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/* global Meteor, _, SimpleSchema, Mongo:true, Match, Package, EJSON */                                              // 1\n                                                                                                                     // 2\n// Extend the schema options allowed by SimpleSchema                                                                 // 3\nSimpleSchema.extendOptions({                                                                                         // 4\n  index: Match.Optional(Match.OneOf(Number, String, Boolean)),                                                       // 5\n  unique: Match.Optional(Boolean),                                                                                   // 6\n  denyInsert: Match.Optional(Boolean),                                                                               // 7\n  denyUpdate: Match.Optional(Boolean)                                                                                // 8\n});                                                                                                                  // 9\n                                                                                                                     // 10\n// Define some extra validation error messages                                                                       // 11\nSimpleSchema.messages({                                                                                              // 12\n  notUnique: \"[label] must be unique\",                                                                               // 13\n  insertNotAllowed: \"[label] cannot be set during an insert\",                                                        // 14\n  updateNotAllowed: \"[label] cannot be set during an update\"                                                         // 15\n});                                                                                                                  // 16\n                                                                                                                     // 17\n/*                                                                                                                   // 18\n * Public API                                                                                                        // 19\n */                                                                                                                  // 20\n                                                                                                                     // 21\n// backwards compatibility                                                                                           // 22\nif (typeof Mongo === \"undefined\") {                                                                                  // 23\n  Mongo = {};                                                                                                        // 24\n  Mongo.Collection = Meteor.Collection;                                                                              // 25\n}                                                                                                                    // 26\n                                                                                                                     // 27\n/**                                                                                                                  // 28\n * Mongo.Collection.prototype.attachSchema                                                                           // 29\n * @param {SimpleSchema|Object} ss - SimpleSchema instance or a schema definition object from which to create a new SimpleSchema instance\n * @param {Object} [options]                                                                                         // 31\n * @param {Boolean} [options.transform=false] Set to `true` if your document must be passed through the collection's transform to properly validate.\n * @param {Boolean} [options.replace=false] Set to `true` to replace any existing schema instead of combining        // 33\n * @return {undefined}                                                                                               // 34\n *                                                                                                                   // 35\n * Use this method to attach a schema to a collection created by another package,                                    // 36\n * such as Meteor.users. It is most likely unsafe to call this method more than                                      // 37\n * once for a single collection, or to call this for a collection that had a                                         // 38\n * schema object passed to its constructor.                                                                          // 39\n */                                                                                                                  // 40\nMongo.Collection.prototype.attachSchema = function c2AttachSchema(ss, options) {                                     // 41\n  var self = this;                                                                                                   // 42\n  options = options || {};                                                                                           // 43\n                                                                                                                     // 44\n  if (!(ss instanceof SimpleSchema)) {                                                                               // 45\n    ss = new SimpleSchema(ss);                                                                                       // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  self._c2 = self._c2 || {};                                                                                         // 49\n                                                                                                                     // 50\n  // If we've already attached one schema, we combine both into a new schema unless options.replace is `true`        // 51\n  if (self._c2._simpleSchema && options.replace !== true) {                                                          // 52\n    ss = new SimpleSchema([self._c2._simpleSchema, ss]);                                                             // 53\n  }                                                                                                                  // 54\n                                                                                                                     // 55\n  // Track the schema in the collection                                                                              // 56\n  self._c2._simpleSchema = ss;                                                                                       // 57\n                                                                                                                     // 58\n  function ensureIndex(c, index, indexName, unique, sparse) {                                                        // 59\n    Meteor.startup(function () {                                                                                     // 60\n      c._collection._ensureIndex(index, {                                                                            // 61\n        background: true,                                                                                            // 62\n        name: indexName,                                                                                             // 63\n        unique: unique,                                                                                              // 64\n        sparse: sparse                                                                                               // 65\n      });                                                                                                            // 66\n    });                                                                                                              // 67\n  }                                                                                                                  // 68\n                                                                                                                     // 69\n  function dropIndex(c, indexName) {                                                                                 // 70\n    Meteor.startup(function () {                                                                                     // 71\n      try {                                                                                                          // 72\n        c._collection._dropIndex(indexName);                                                                         // 73\n      } catch (err) {                                                                                                // 74\n        // no index with that name, which is what we want                                                            // 75\n      }                                                                                                              // 76\n    });                                                                                                              // 77\n  }                                                                                                                  // 78\n                                                                                                                     // 79\n  // Loop over fields definitions and ensure collection indexes (server side only)                                   // 80\n  if (Meteor.isServer) {                                                                                             // 81\n    _.each(ss.schema(), function(definition, fieldName) {                                                            // 82\n      if ('index' in definition || definition.unique === true) {                                                     // 83\n        var index = {}, indexValue;                                                                                  // 84\n        // If they specified `unique: true` but not `index`,                                                         // 85\n        // we assume `index: 1` to set up the unique index in mongo                                                  // 86\n        if ('index' in definition) {                                                                                 // 87\n          indexValue = definition.index;                                                                             // 88\n          if (indexValue === true) {                                                                                 // 89\n            indexValue = 1;                                                                                          // 90\n          }                                                                                                          // 91\n        } else {                                                                                                     // 92\n          indexValue = 1;                                                                                            // 93\n        }                                                                                                            // 94\n        var indexName = 'c2_' + fieldName;                                                                           // 95\n        // In the index object, we want object array keys without the \".$\" piece                                     // 96\n        var idxFieldName = fieldName.replace(/\\.\\$\\./g, \".\");                                                        // 97\n        index[idxFieldName] = indexValue;                                                                            // 98\n        var unique = !!definition.unique && (indexValue === 1 || indexValue === -1);                                 // 99\n        var sparse = !!definition.optional && unique;                                                                // 100\n                                                                                                                     // 101\n        if (indexValue === false) {                                                                                  // 102\n          dropIndex(self, indexName);                                                                                // 103\n        } else {                                                                                                     // 104\n          ensureIndex(self, index, indexName, unique, sparse);                                                       // 105\n        }                                                                                                            // 106\n      }                                                                                                              // 107\n    });                                                                                                              // 108\n  }                                                                                                                  // 109\n                                                                                                                     // 110\n  // Set up additional checks                                                                                        // 111\n  ss.validator(function() {                                                                                          // 112\n    var def = this.definition;                                                                                       // 113\n    var val = this.value;                                                                                            // 114\n    var op = this.operator;                                                                                          // 115\n                                                                                                                     // 116\n    if (def.denyInsert && val !== void 0 && !op) {                                                                   // 117\n      // This is an insert of a defined value into a field where denyInsert=true                                     // 118\n      return \"insertNotAllowed\";                                                                                     // 119\n    }                                                                                                                // 120\n                                                                                                                     // 121\n    if (def.denyUpdate && op) {                                                                                      // 122\n      // This is an insert of a defined value into a field where denyUpdate=true                                     // 123\n      if (op !== \"$set\" || (op === \"$set\" && val !== void 0)) {                                                      // 124\n        return \"updateNotAllowed\";                                                                                   // 125\n      }                                                                                                              // 126\n    }                                                                                                                // 127\n                                                                                                                     // 128\n    return true;                                                                                                     // 129\n  });                                                                                                                // 130\n                                                                                                                     // 131\n  defineDeny(self, options);                                                                                         // 132\n  keepInsecure(self);                                                                                                // 133\n};                                                                                                                   // 134\n                                                                                                                     // 135\nMongo.Collection.prototype.simpleSchema = function c2SS() {                                                          // 136\n  var self = this;                                                                                                   // 137\n  return self._c2 ? self._c2._simpleSchema : null;                                                                   // 138\n};                                                                                                                   // 139\n                                                                                                                     // 140\n// Wrap DB write operation methods                                                                                   // 141\n_.each(['insert', 'update', 'upsert'], function(methodName) {                                                        // 142\n  var _super = Mongo.Collection.prototype[methodName];                                                               // 143\n  Mongo.Collection.prototype[methodName] = function () {                                                             // 144\n    var self = this, args = _.toArray(arguments);                                                                    // 145\n    if (self._c2) {                                                                                                  // 146\n      args = doValidate.call(self, methodName, args, false,                                                          // 147\n        (Meteor.isClient && Meteor.userId && Meteor.userId()) || null, Meteor.isServer);                             // 148\n      if (!args) {                                                                                                   // 149\n        // doValidate already called the callback or threw the error                                                 // 150\n        if (methodName === \"insert\") {                                                                               // 151\n          // insert should always return an ID to match core behavior                                                // 152\n          return self._makeNewID();                                                                                  // 153\n        } else {                                                                                                     // 154\n          return;                                                                                                    // 155\n        }                                                                                                            // 156\n      }                                                                                                              // 157\n    }                                                                                                                // 158\n    return _super.apply(self, args);                                                                                 // 159\n  };                                                                                                                 // 160\n});                                                                                                                  // 161\n                                                                                                                     // 162\n/*                                                                                                                   // 163\n * Private                                                                                                           // 164\n */                                                                                                                  // 165\n                                                                                                                     // 166\nfunction doValidate(type, args, skipAutoValue, userId, isFromTrustedCode) {                                          // 167\n  var self = this, schema = self._c2._simpleSchema,                                                                  // 168\n      doc, callback, error, options, isUpsert, selector, last, hasCallback,                                          // 169\n      isLocalCollection = (self._connection === null);                                                               // 170\n                                                                                                                     // 171\n  if (!args.length) {                                                                                                // 172\n    throw new Error(type + \" requires an argument\");                                                                 // 173\n  }                                                                                                                  // 174\n                                                                                                                     // 175\n  // Gather arguments and cache the selector                                                                         // 176\n  if (type === \"insert\") {                                                                                           // 177\n    doc = args[0];                                                                                                   // 178\n    options = args[1];                                                                                               // 179\n    callback = args[2];                                                                                              // 180\n                                                                                                                     // 181\n    // The real insert doesn't take options                                                                          // 182\n    if (typeof options === \"function\") {                                                                             // 183\n      args = [doc, options];                                                                                         // 184\n    } else if (typeof callback === \"function\") {                                                                     // 185\n      args = [doc, callback];                                                                                        // 186\n    } else {                                                                                                         // 187\n      args = [doc];                                                                                                  // 188\n    }                                                                                                                // 189\n                                                                                                                     // 190\n  } else if (type === \"update\" || type === \"upsert\") {                                                               // 191\n    selector = args[0];                                                                                              // 192\n    doc = args[1];                                                                                                   // 193\n    options = args[2];                                                                                               // 194\n    callback = args[3];                                                                                              // 195\n  } else {                                                                                                           // 196\n    throw new Error(\"invalid type argument\");                                                                        // 197\n  }                                                                                                                  // 198\n                                                                                                                     // 199\n  // Support missing options arg                                                                                     // 200\n  if (!callback && typeof options === \"function\") {                                                                  // 201\n    callback = options;                                                                                              // 202\n    options = {};                                                                                                    // 203\n  }                                                                                                                  // 204\n  options = options || {};                                                                                           // 205\n                                                                                                                     // 206\n  last = args.length - 1;                                                                                            // 207\n                                                                                                                     // 208\n  hasCallback = (typeof args[last] === 'function');                                                                  // 209\n                                                                                                                     // 210\n  // If update was called with upsert:true or upsert was called, flag as an upsert                                   // 211\n  isUpsert = (type === \"upsert\" || (type === \"update\" && options.upsert === true));                                  // 212\n                                                                                                                     // 213\n  // Add a default callback function if we're on the client and no callback was given                                // 214\n  if (Meteor.isClient && !callback) {                                                                                // 215\n    // Client can't block, so it can't report errors by exception,                                                   // 216\n    // only by callback. If they forget the callback, give them a                                                    // 217\n    // default one that logs the error, so they aren't totally                                                       // 218\n    // baffled if their writes don't work because their database is                                                  // 219\n    // down.                                                                                                         // 220\n    callback = function(err) {                                                                                       // 221\n      if (err) {                                                                                                     // 222\n        Meteor._debug(type + \" failed: \" + (err.reason || err.stack));                                               // 223\n      }                                                                                                              // 224\n    };                                                                                                               // 225\n  }                                                                                                                  // 226\n                                                                                                                     // 227\n  // If client validation is fine or is skipped but then something                                                   // 228\n  // is found to be invalid on the server, we get that error back                                                    // 229\n  // as a special Meteor.Error that we need to parse.                                                                // 230\n  if (Meteor.isClient && hasCallback) {                                                                              // 231\n    callback = args[last] = wrapCallbackForParsingServerErrors(self, options.validationContext, callback);           // 232\n  }                                                                                                                  // 233\n                                                                                                                     // 234\n  // If _id has already been added, remove it temporarily if it's                                                    // 235\n  // not explicitly defined in the schema.                                                                           // 236\n  var id;                                                                                                            // 237\n  if (doc._id && !schema.allowsKey(\"_id\")) {                                                                         // 238\n    id = doc._id;                                                                                                    // 239\n    delete doc._id;                                                                                                  // 240\n  }                                                                                                                  // 241\n                                                                                                                     // 242\n  function doClean(docToClean, getAutoValues, filter, autoConvert, removeEmptyStrings, trimStrings) {                // 243\n    // Clean the doc/modifier in place                                                                               // 244\n    schema.clean(docToClean, {                                                                                       // 245\n      filter: filter,                                                                                                // 246\n      autoConvert: autoConvert,                                                                                      // 247\n      getAutoValues: getAutoValues,                                                                                  // 248\n      isModifier: (type !== \"insert\"),                                                                               // 249\n      removeEmptyStrings: removeEmptyStrings,                                                                        // 250\n      trimStrings: trimStrings,                                                                                      // 251\n      extendAutoValueContext: _.extend({                                                                             // 252\n        isInsert: (type === \"insert\"),                                                                               // 253\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 254\n        isUpsert: isUpsert,                                                                                          // 255\n        userId: userId,                                                                                              // 256\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 257\n        docId: ((type === \"update\" || type === \"upsert\") && selector) ? selector._id || selector : void 0,           // 258\n        isLocalCollection: isLocalCollection                                                                         // 259\n      }, options.extendAutoValueContext || {})                                                                       // 260\n    });                                                                                                              // 261\n  }                                                                                                                  // 262\n                                                                                                                     // 263\n  // On the server and for local collections, we allow passing `getAutoValues: false` to disable autoValue functions // 264\n  if ((Meteor.isServer || isLocalCollection) && options.getAutoValues === false) {                                   // 265\n    skipAutoValue = true;                                                                                            // 266\n  }                                                                                                                  // 267\n                                                                                                                     // 268\n  // Preliminary cleaning on both client and server. On the server and for local                                     // 269\n  // collections, automatic values will also be set at this point.                                                   // 270\n  doClean(doc, ((Meteor.isServer || isLocalCollection) && !skipAutoValue), options.filter !== false, options.autoConvert !== false, options.removeEmptyStrings !== false, options.trimStrings !== false);\n                                                                                                                     // 272\n  // We clone before validating because in some cases we need to adjust the                                          // 273\n  // object a bit before validating it. If we adjusted `doc` itself, our                                             // 274\n  // changes would persist into the database.                                                                        // 275\n  var docToValidate = {};                                                                                            // 276\n  for (var prop in doc) {                                                                                            // 277\n    // We omit prototype properties when cloning because they will not be valid                                      // 278\n    // and mongo omits them when saving to the database anyway.                                                      // 279\n    if (doc.hasOwnProperty(prop)) {                                                                                  // 280\n      docToValidate[prop] = doc[prop];                                                                               // 281\n    }                                                                                                                // 282\n  }                                                                                                                  // 283\n                                                                                                                     // 284\n  // On the server, upserts are possible; SimpleSchema handles upserts pretty                                        // 285\n  // well by default, but it will not know about the fields in the selector,                                         // 286\n  // which are also stored in the database if an insert is performed. So we                                          // 287\n  // will allow these fields to be considered for validation by adding them                                          // 288\n  // to the $set in the modifier. This is no doubt prone to errors, but there                                        // 289\n  // probably isn't any better way right now.                                                                        // 290\n  if (Meteor.isServer && isUpsert && _.isObject(selector)) {                                                         // 291\n    var set = docToValidate.$set || {};                                                                              // 292\n    docToValidate.$set = _.clone(selector);                                                                          // 293\n    _.extend(docToValidate.$set, set);                                                                               // 294\n  }                                                                                                                  // 295\n                                                                                                                     // 296\n  // Set automatic values for validation on the client.                                                              // 297\n  // On the server, we already updated doc with auto values, but on the client,                                      // 298\n  // we will add them to docToValidate for validation purposes only.                                                 // 299\n  // This is because we want all actual values generated on the server.                                              // 300\n  if (Meteor.isClient && !isLocalCollection) {                                                                       // 301\n    doClean(docToValidate, true, false, false, false, false);                                                        // 302\n  }                                                                                                                  // 303\n                                                                                                                     // 304\n  // Validate doc                                                                                                    // 305\n  var ctx = schema.namedContext(options.validationContext);                                                          // 306\n  var isValid;                                                                                                       // 307\n  if (options.validate === false) {                                                                                  // 308\n    isValid = true;                                                                                                  // 309\n  } else {                                                                                                           // 310\n    isValid = ctx.validate(docToValidate, {                                                                          // 311\n      modifier: (type === \"update\" || type === \"upsert\"),                                                            // 312\n      upsert: isUpsert,                                                                                              // 313\n      extendedCustomContext: _.extend({                                                                              // 314\n        isInsert: (type === \"insert\"),                                                                               // 315\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 316\n        isUpsert: isUpsert,                                                                                          // 317\n        userId: userId,                                                                                              // 318\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 319\n        docId: ((type === \"update\" || type === \"upsert\") && selector) ? selector._id || selector : void 0,           // 320\n        isLocalCollection: isLocalCollection                                                                         // 321\n      }, options.extendedCustomContext || {})                                                                        // 322\n    });                                                                                                              // 323\n  }                                                                                                                  // 324\n                                                                                                                     // 325\n  if (isValid) {                                                                                                     // 326\n    // Add the ID back                                                                                               // 327\n    if (id) {                                                                                                        // 328\n      doc._id = id;                                                                                                  // 329\n    }                                                                                                                // 330\n                                                                                                                     // 331\n    // Update the args to reflect the cleaned doc                                                                    // 332\n    if (type === \"insert\") {                                                                                         // 333\n      args[0] = doc;                                                                                                 // 334\n    } else {                                                                                                         // 335\n      args[1] = doc;                                                                                                 // 336\n    }                                                                                                                // 337\n                                                                                                                     // 338\n    // If callback, set invalidKey when we get a mongo unique error                                                  // 339\n    if (Meteor.isServer && hasCallback) {                                                                            // 340\n      args[last] = wrapCallbackForParsingMongoValidationErrors(self, doc, options.validationContext, args[last]);    // 341\n    }                                                                                                                // 342\n                                                                                                                     // 343\n    return args;                                                                                                     // 344\n  } else {                                                                                                           // 345\n    error = getErrorObject(ctx);                                                                                     // 346\n    if (callback) {                                                                                                  // 347\n      // insert/update/upsert pass `false` when there's an error, so we do that                                      // 348\n      callback(error, false);                                                                                        // 349\n    } else {                                                                                                         // 350\n      throw error;                                                                                                   // 351\n    }                                                                                                                // 352\n  }                                                                                                                  // 353\n}                                                                                                                    // 354\n                                                                                                                     // 355\nfunction getErrorObject(context) {                                                                                   // 356\n  var message, invalidKeys = context.invalidKeys();                                                                  // 357\n  if (invalidKeys.length) {                                                                                          // 358\n    message = context.keyErrorMessage(invalidKeys[0].name);                                                          // 359\n  } else {                                                                                                           // 360\n    message = \"Failed validation\";                                                                                   // 361\n  }                                                                                                                  // 362\n  var error = new Error(message);                                                                                    // 363\n  error.invalidKeys = invalidKeys;                                                                                   // 364\n  error.validationContext = context;                                                                                 // 365\n  // If on the server, we add a sanitized error, too, in case we're                                                  // 366\n  // called from a method.                                                                                           // 367\n  if (Meteor.isServer) {                                                                                             // 368\n    error.sanitizedError = new Meteor.Error(400, message);                                                           // 369\n  }                                                                                                                  // 370\n  return error;                                                                                                      // 371\n}                                                                                                                    // 372\n                                                                                                                     // 373\nfunction addUniqueError(context, errorMessage) {                                                                     // 374\n  var name = errorMessage.split('c2_')[1].split(' ')[0];                                                             // 375\n  var val = errorMessage.split('dup key:')[1].split('\"')[1];                                                         // 376\n  context.addInvalidKeys([{                                                                                          // 377\n    name: name,                                                                                                      // 378\n    type: 'notUnique',                                                                                               // 379\n    value: val                                                                                                       // 380\n  }]);                                                                                                               // 381\n}                                                                                                                    // 382\n                                                                                                                     // 383\nfunction wrapCallbackForParsingMongoValidationErrors(col, doc, vCtx, cb) {                                           // 384\n  return function wrappedCallbackForParsingMongoValidationErrors(error) {                                            // 385\n    if (error && ((error.name === \"MongoError\" && error.code === 11001) || error.message.indexOf('MongoError: E11000' !== -1)) && error.message.indexOf('c2_') !== -1) {\n      var context = col.simpleSchema().namedContext(vCtx);                                                           // 387\n      addUniqueError(context, error.message);                                                                        // 388\n      arguments[0] = getErrorObject(context);                                                                        // 389\n    }                                                                                                                // 390\n    return cb.apply(this, arguments);                                                                                // 391\n  };                                                                                                                 // 392\n}                                                                                                                    // 393\n                                                                                                                     // 394\nfunction wrapCallbackForParsingServerErrors(col, vCtx, cb) {                                                         // 395\n  return function wrappedCallbackForParsingServerErrors(error) {                                                     // 396\n    // Handle our own validation errors                                                                              // 397\n    var context = col.simpleSchema().namedContext(vCtx);                                                             // 398\n    if (error instanceof Meteor.Error && error.error === 400 && error.reason === \"INVALID\" && typeof error.details === \"string\") {\n      var invalidKeysFromServer = EJSON.parse(error.details);                                                        // 400\n      context.addInvalidKeys(invalidKeysFromServer);                                                                 // 401\n      arguments[0] = getErrorObject(context);                                                                        // 402\n    }                                                                                                                // 403\n    // Handle Mongo unique index errors, which are forwarded to the client as 409 errors                             // 404\n    else if (error instanceof Meteor.Error && error.error === 409 && error.reason && error.reason.indexOf('E11000') !== -1 && error.reason.indexOf('c2_') !== -1) {\n      addUniqueError(context, error.reason);                                                                         // 406\n      arguments[0] = getErrorObject(context);                                                                        // 407\n    }                                                                                                                // 408\n    return cb.apply(this, arguments);                                                                                // 409\n  };                                                                                                                 // 410\n}                                                                                                                    // 411\n                                                                                                                     // 412\nvar alreadyInsecured = {};                                                                                           // 413\nfunction keepInsecure(c) {                                                                                           // 414\n  // If insecure package is in use, we need to add allow rules that return                                           // 415\n  // true. Otherwise, it would seemingly turn off insecure mode.                                                     // 416\n  if (Package && Package.insecure && !alreadyInsecured[c._name]) {                                                   // 417\n    c.allow({                                                                                                        // 418\n      insert: function() {                                                                                           // 419\n        return true;                                                                                                 // 420\n      },                                                                                                             // 421\n      update: function() {                                                                                           // 422\n        return true;                                                                                                 // 423\n      },                                                                                                             // 424\n      remove: function () {                                                                                          // 425\n        return true;                                                                                                 // 426\n      },                                                                                                             // 427\n      fetch: [],                                                                                                     // 428\n      transform: null                                                                                                // 429\n    });                                                                                                              // 430\n    alreadyInsecured[c._name] = true;                                                                                // 431\n  }                                                                                                                  // 432\n  // If insecure package is NOT in use, then adding the two deny functions                                           // 433\n  // does not have any effect on the main app's security paradigm. The                                               // 434\n  // user will still be required to add at least one allow function of her                                           // 435\n  // own for each operation for this collection. And the user may still add                                          // 436\n  // additional deny functions, but does not have to.                                                                // 437\n}                                                                                                                    // 438\n                                                                                                                     // 439\nvar alreadyDefined = {};                                                                                             // 440\nfunction defineDeny(c, options) {                                                                                    // 441\n  if (!alreadyDefined[c._name]) {                                                                                    // 442\n                                                                                                                     // 443\n    var isLocalCollection = (c._connection === null);                                                                // 444\n                                                                                                                     // 445\n    // First define deny functions to extend doc with the results of clean                                           // 446\n    // and autovalues. This must be done with \"transform: null\" or we would be                                       // 447\n    // extending a clone of doc and therefore have no effect.                                                        // 448\n    c.deny({                                                                                                         // 449\n      insert: function(userId, doc) {                                                                                // 450\n        var ss = c.simpleSchema();                                                                                   // 451\n        // If _id has already been added, remove it temporarily if it's                                              // 452\n        // not explicitly defined in the schema.                                                                     // 453\n        var id;                                                                                                      // 454\n        if (Meteor.isServer && doc._id && !ss.allowsKey(\"_id\")) {                                                    // 455\n          id = doc._id;                                                                                              // 456\n          delete doc._id;                                                                                            // 457\n        }                                                                                                            // 458\n                                                                                                                     // 459\n        // Referenced doc is cleaned in place                                                                        // 460\n        ss.clean(doc, {                                                                                              // 461\n          isModifier: false,                                                                                         // 462\n          // We don't do these here because they are done on the client if desired                                   // 463\n          filter: false,                                                                                             // 464\n          autoConvert: false,                                                                                        // 465\n          removeEmptyStrings: false,                                                                                 // 466\n          trimStrings: false,                                                                                        // 467\n          extendAutoValueContext: {                                                                                  // 468\n            isInsert: true,                                                                                          // 469\n            isUpdate: false,                                                                                         // 470\n            isUpsert: false,                                                                                         // 471\n            userId: userId,                                                                                          // 472\n            isFromTrustedCode: false,                                                                                // 473\n            docId: id,                                                                                               // 474\n            isLocalCollection: isLocalCollection                                                                     // 475\n          }                                                                                                          // 476\n        });                                                                                                          // 477\n                                                                                                                     // 478\n        // Add the ID back                                                                                           // 479\n        if (id) {                                                                                                    // 480\n          doc._id = id;                                                                                              // 481\n        }                                                                                                            // 482\n                                                                                                                     // 483\n        return false;                                                                                                // 484\n      },                                                                                                             // 485\n      update: function(userId, doc, fields, modifier) {                                                              // 486\n        var ss = c.simpleSchema();                                                                                   // 487\n        // Referenced modifier is cleaned in place                                                                   // 488\n        ss.clean(modifier, {                                                                                         // 489\n          isModifier: true,                                                                                          // 490\n          // We don't do these here because they are done on the client if desired                                   // 491\n          filter: false,                                                                                             // 492\n          autoConvert: false,                                                                                        // 493\n          removeEmptyStrings: false,                                                                                 // 494\n          trimStrings: false,                                                                                        // 495\n          extendAutoValueContext: {                                                                                  // 496\n            isInsert: false,                                                                                         // 497\n            isUpdate: true,                                                                                          // 498\n            isUpsert: false,                                                                                         // 499\n            userId: userId,                                                                                          // 500\n            isFromTrustedCode: false,                                                                                // 501\n            docId: doc && doc._id,                                                                                   // 502\n            isLocalCollection: isLocalCollection                                                                     // 503\n          }                                                                                                          // 504\n        });                                                                                                          // 505\n                                                                                                                     // 506\n        return false;                                                                                                // 507\n      },                                                                                                             // 508\n      fetch: ['_id'],                                                                                                // 509\n      transform: null                                                                                                // 510\n    });                                                                                                              // 511\n                                                                                                                     // 512\n    // Second define deny functions to validate again on the server                                                  // 513\n    // for client-initiated inserts and updates. These should be                                                     // 514\n    // called after the clean/autovalue functions since we're adding                                                 // 515\n    // them after. These must *not* have \"transform: null\" if options.transform is true because                      // 516\n    // we need to pass the doc through any transforms to be sure                                                     // 517\n    // that custom types are properly recognized for type validation.                                                // 518\n    c.deny(_.extend({                                                                                                // 519\n      insert: function(userId, doc) {                                                                                // 520\n        // We pass the false options because we will have done them on client if desired                             // 521\n        doValidate.call(c, \"insert\", [doc, {trimStrings: false, removeEmptyStrings: false, filter: false, autoConvert: false}, function(error) {\n            if (error) {                                                                                             // 523\n              throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                            // 524\n            }                                                                                                        // 525\n          }], true, userId, false);                                                                                  // 526\n                                                                                                                     // 527\n        return false;                                                                                                // 528\n      },                                                                                                             // 529\n      update: function(userId, doc, fields, modifier) {                                                              // 530\n        // NOTE: This will never be an upsert because client-side upserts                                            // 531\n        // are not allowed once you define allow/deny functions.                                                     // 532\n        // We pass the false options because we will have done them on client if desired                             // 533\n        doValidate.call(c, \"update\", [{_id: doc && doc._id}, modifier, {trimStrings: false, removeEmptyStrings: false, filter: false, autoConvert: false}, function(error) {\n            if (error) {                                                                                             // 535\n              throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                            // 536\n            }                                                                                                        // 537\n          }], true, userId, false);                                                                                  // 538\n                                                                                                                     // 539\n        return false;                                                                                                // 540\n      },                                                                                                             // 541\n      fetch: ['_id']                                                                                                 // 542\n    }, options.transform === true ? {} : {transform: null}));                                                        // 543\n                                                                                                                     // 544\n    // note that we've already done this collection so that we don't do it again                                     // 545\n    // if attachSchema is called again                                                                               // 546\n    alreadyDefined[c._name] = true;                                                                                  // 547\n  }                                                                                                                  // 548\n}                                                                                                                    // 549\n                                                                                                                     // 550\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                     // 560\n}).call(this);                                                       // 561\n                                                                     // 562\n///////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['aldeed:collection2'] = {};\n\n})();\n","servePath":"/packages/aldeed_collection2.js","sourceMap":{"version":3,"sources":["/packages/aldeed_collection2/packages/aldeed_collection2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2E","file":"/packages/aldeed_collection2.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/aldeed:collection2/collection2.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/* global Meteor, _, SimpleSchema, Mongo:true, Match, Package, EJSON */                                              // 1\n                                                                                                                     // 2\n// Extend the schema options allowed by SimpleSchema                                                                 // 3\nSimpleSchema.extendOptions({                                                                                         // 4\n  index: Match.Optional(Match.OneOf(Number, String, Boolean)),                                                       // 5\n  unique: Match.Optional(Boolean),                                                                                   // 6\n  denyInsert: Match.Optional(Boolean),                                                                               // 7\n  denyUpdate: Match.Optional(Boolean)                                                                                // 8\n});                                                                                                                  // 9\n                                                                                                                     // 10\n// Define some extra validation error messages                                                                       // 11\nSimpleSchema.messages({                                                                                              // 12\n  notUnique: \"[label] must be unique\",                                                                               // 13\n  insertNotAllowed: \"[label] cannot be set during an insert\",                                                        // 14\n  updateNotAllowed: \"[label] cannot be set during an update\"                                                         // 15\n});                                                                                                                  // 16\n                                                                                                                     // 17\n/*                                                                                                                   // 18\n * Public API                                                                                                        // 19\n */                                                                                                                  // 20\n                                                                                                                     // 21\n// backwards compatibility                                                                                           // 22\nif (typeof Mongo === \"undefined\") {                                                                                  // 23\n  Mongo = {};                                                                                                        // 24\n  Mongo.Collection = Meteor.Collection;                                                                              // 25\n}                                                                                                                    // 26\n                                                                                                                     // 27\n/**                                                                                                                  // 28\n * Mongo.Collection.prototype.attachSchema                                                                           // 29\n * @param {SimpleSchema|Object} ss - SimpleSchema instance or a schema definition object from which to create a new SimpleSchema instance\n * @param {Object} [options]                                                                                         // 31\n * @param {Boolean} [options.transform=false] Set to `true` if your document must be passed through the collection's transform to properly validate.\n * @param {Boolean} [options.replace=false] Set to `true` to replace any existing schema instead of combining        // 33\n * @return {undefined}                                                                                               // 34\n *                                                                                                                   // 35\n * Use this method to attach a schema to a collection created by another package,                                    // 36\n * such as Meteor.users. It is most likely unsafe to call this method more than                                      // 37\n * once for a single collection, or to call this for a collection that had a                                         // 38\n * schema object passed to its constructor.                                                                          // 39\n */                                                                                                                  // 40\nMongo.Collection.prototype.attachSchema = function c2AttachSchema(ss, options) {                                     // 41\n  var self = this;                                                                                                   // 42\n  options = options || {};                                                                                           // 43\n                                                                                                                     // 44\n  if (!(ss instanceof SimpleSchema)) {                                                                               // 45\n    ss = new SimpleSchema(ss);                                                                                       // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  self._c2 = self._c2 || {};                                                                                         // 49\n                                                                                                                     // 50\n  // If we've already attached one schema, we combine both into a new schema unless options.replace is `true`        // 51\n  if (self._c2._simpleSchema && options.replace !== true) {                                                          // 52\n    ss = new SimpleSchema([self._c2._simpleSchema, ss]);                                                             // 53\n  }                                                                                                                  // 54\n                                                                                                                     // 55\n  // Track the schema in the collection                                                                              // 56\n  self._c2._simpleSchema = ss;                                                                                       // 57\n                                                                                                                     // 58\n  function ensureIndex(c, index, indexName, unique, sparse) {                                                        // 59\n    Meteor.startup(function () {                                                                                     // 60\n      c._collection._ensureIndex(index, {                                                                            // 61\n        background: true,                                                                                            // 62\n        name: indexName,                                                                                             // 63\n        unique: unique,                                                                                              // 64\n        sparse: sparse                                                                                               // 65\n      });                                                                                                            // 66\n    });                                                                                                              // 67\n  }                                                                                                                  // 68\n                                                                                                                     // 69\n  function dropIndex(c, indexName) {                                                                                 // 70\n    Meteor.startup(function () {                                                                                     // 71\n      try {                                                                                                          // 72\n        c._collection._dropIndex(indexName);                                                                         // 73\n      } catch (err) {                                                                                                // 74\n        // no index with that name, which is what we want                                                            // 75\n      }                                                                                                              // 76\n    });                                                                                                              // 77\n  }                                                                                                                  // 78\n                                                                                                                     // 79\n  // Loop over fields definitions and ensure collection indexes (server side only)                                   // 80\n  if (Meteor.isServer) {                                                                                             // 81\n    _.each(ss.schema(), function(definition, fieldName) {                                                            // 82\n      if ('index' in definition || definition.unique === true) {                                                     // 83\n        var index = {}, indexValue;                                                                                  // 84\n        // If they specified `unique: true` but not `index`,                                                         // 85\n        // we assume `index: 1` to set up the unique index in mongo                                                  // 86\n        if ('index' in definition) {                                                                                 // 87\n          indexValue = definition.index;                                                                             // 88\n          if (indexValue === true) {                                                                                 // 89\n            indexValue = 1;                                                                                          // 90\n          }                                                                                                          // 91\n        } else {                                                                                                     // 92\n          indexValue = 1;                                                                                            // 93\n        }                                                                                                            // 94\n        var indexName = 'c2_' + fieldName;                                                                           // 95\n        // In the index object, we want object array keys without the \".$\" piece                                     // 96\n        var idxFieldName = fieldName.replace(/\\.\\$\\./g, \".\");                                                        // 97\n        index[idxFieldName] = indexValue;                                                                            // 98\n        var unique = !!definition.unique && (indexValue === 1 || indexValue === -1);                                 // 99\n        var sparse = !!definition.optional && unique;                                                                // 100\n                                                                                                                     // 101\n        if (indexValue === false) {                                                                                  // 102\n          dropIndex(self, indexName);                                                                                // 103\n        } else {                                                                                                     // 104\n          ensureIndex(self, index, indexName, unique, sparse);                                                       // 105\n        }                                                                                                            // 106\n      }                                                                                                              // 107\n    });                                                                                                              // 108\n  }                                                                                                                  // 109\n                                                                                                                     // 110\n  // Set up additional checks                                                                                        // 111\n  ss.validator(function() {                                                                                          // 112\n    var def = this.definition;                                                                                       // 113\n    var val = this.value;                                                                                            // 114\n    var op = this.operator;                                                                                          // 115\n                                                                                                                     // 116\n    if (def.denyInsert && val !== void 0 && !op) {                                                                   // 117\n      // This is an insert of a defined value into a field where denyInsert=true                                     // 118\n      return \"insertNotAllowed\";                                                                                     // 119\n    }                                                                                                                // 120\n                                                                                                                     // 121\n    if (def.denyUpdate && op) {                                                                                      // 122\n      // This is an insert of a defined value into a field where denyUpdate=true                                     // 123\n      if (op !== \"$set\" || (op === \"$set\" && val !== void 0)) {                                                      // 124\n        return \"updateNotAllowed\";                                                                                   // 125\n      }                                                                                                              // 126\n    }                                                                                                                // 127\n                                                                                                                     // 128\n    return true;                                                                                                     // 129\n  });                                                                                                                // 130\n                                                                                                                     // 131\n  defineDeny(self, options);                                                                                         // 132\n  keepInsecure(self);                                                                                                // 133\n};                                                                                                                   // 134\n                                                                                                                     // 135\nMongo.Collection.prototype.simpleSchema = function c2SS() {                                                          // 136\n  var self = this;                                                                                                   // 137\n  return self._c2 ? self._c2._simpleSchema : null;                                                                   // 138\n};                                                                                                                   // 139\n                                                                                                                     // 140\n// Wrap DB write operation methods                                                                                   // 141\n_.each(['insert', 'update', 'upsert'], function(methodName) {                                                        // 142\n  var _super = Mongo.Collection.prototype[methodName];                                                               // 143\n  Mongo.Collection.prototype[methodName] = function () {                                                             // 144\n    var self = this, args = _.toArray(arguments);                                                                    // 145\n    if (self._c2) {                                                                                                  // 146\n      args = doValidate.call(self, methodName, args, false,                                                          // 147\n        (Meteor.isClient && Meteor.userId && Meteor.userId()) || null, Meteor.isServer);                             // 148\n      if (!args) {                                                                                                   // 149\n        // doValidate already called the callback or threw the error                                                 // 150\n        if (methodName === \"insert\") {                                                                               // 151\n          // insert should always return an ID to match core behavior                                                // 152\n          return self._makeNewID();                                                                                  // 153\n        } else {                                                                                                     // 154\n          return;                                                                                                    // 155\n        }                                                                                                            // 156\n      }                                                                                                              // 157\n    }                                                                                                                // 158\n    return _super.apply(self, args);                                                                                 // 159\n  };                                                                                                                 // 160\n});                                                                                                                  // 161\n                                                                                                                     // 162\n/*                                                                                                                   // 163\n * Private                                                                                                           // 164\n */                                                                                                                  // 165\n                                                                                                                     // 166\nfunction doValidate(type, args, skipAutoValue, userId, isFromTrustedCode) {                                          // 167\n  var self = this, schema = self._c2._simpleSchema,                                                                  // 168\n      doc, callback, error, options, isUpsert, selector, last, hasCallback,                                          // 169\n      isLocalCollection = (self._connection === null);                                                               // 170\n                                                                                                                     // 171\n  if (!args.length) {                                                                                                // 172\n    throw new Error(type + \" requires an argument\");                                                                 // 173\n  }                                                                                                                  // 174\n                                                                                                                     // 175\n  // Gather arguments and cache the selector                                                                         // 176\n  if (type === \"insert\") {                                                                                           // 177\n    doc = args[0];                                                                                                   // 178\n    options = args[1];                                                                                               // 179\n    callback = args[2];                                                                                              // 180\n                                                                                                                     // 181\n    // The real insert doesn't take options                                                                          // 182\n    if (typeof options === \"function\") {                                                                             // 183\n      args = [doc, options];                                                                                         // 184\n    } else if (typeof callback === \"function\") {                                                                     // 185\n      args = [doc, callback];                                                                                        // 186\n    } else {                                                                                                         // 187\n      args = [doc];                                                                                                  // 188\n    }                                                                                                                // 189\n                                                                                                                     // 190\n  } else if (type === \"update\" || type === \"upsert\") {                                                               // 191\n    selector = args[0];                                                                                              // 192\n    doc = args[1];                                                                                                   // 193\n    options = args[2];                                                                                               // 194\n    callback = args[3];                                                                                              // 195\n  } else {                                                                                                           // 196\n    throw new Error(\"invalid type argument\");                                                                        // 197\n  }                                                                                                                  // 198\n                                                                                                                     // 199\n  // Support missing options arg                                                                                     // 200\n  if (!callback && typeof options === \"function\") {                                                                  // 201\n    callback = options;                                                                                              // 202\n    options = {};                                                                                                    // 203\n  }                                                                                                                  // 204\n  options = options || {};                                                                                           // 205\n                                                                                                                     // 206\n  last = args.length - 1;                                                                                            // 207\n                                                                                                                     // 208\n  hasCallback = (typeof args[last] === 'function');                                                                  // 209\n                                                                                                                     // 210\n  // If update was called with upsert:true or upsert was called, flag as an upsert                                   // 211\n  isUpsert = (type === \"upsert\" || (type === \"update\" && options.upsert === true));                                  // 212\n                                                                                                                     // 213\n  // Add a default callback function if we're on the client and no callback was given                                // 214\n  if (Meteor.isClient && !callback) {                                                                                // 215\n    // Client can't block, so it can't report errors by exception,                                                   // 216\n    // only by callback. If they forget the callback, give them a                                                    // 217\n    // default one that logs the error, so they aren't totally                                                       // 218\n    // baffled if their writes don't work because their database is                                                  // 219\n    // down.                                                                                                         // 220\n    callback = function(err) {                                                                                       // 221\n      if (err) {                                                                                                     // 222\n        Meteor._debug(type + \" failed: \" + (err.reason || err.stack));                                               // 223\n      }                                                                                                              // 224\n    };                                                                                                               // 225\n  }                                                                                                                  // 226\n                                                                                                                     // 227\n  // If client validation is fine or is skipped but then something                                                   // 228\n  // is found to be invalid on the server, we get that error back                                                    // 229\n  // as a special Meteor.Error that we need to parse.                                                                // 230\n  if (Meteor.isClient && hasCallback) {                                                                              // 231\n    callback = args[last] = wrapCallbackForParsingServerErrors(self, options.validationContext, callback);           // 232\n  }                                                                                                                  // 233\n                                                                                                                     // 234\n  // If _id has already been added, remove it temporarily if it's                                                    // 235\n  // not explicitly defined in the schema.                                                                           // 236\n  var id;                                                                                                            // 237\n  if (doc._id && !schema.allowsKey(\"_id\")) {                                                                         // 238\n    id = doc._id;                                                                                                    // 239\n    delete doc._id;                                                                                                  // 240\n  }                                                                                                                  // 241\n                                                                                                                     // 242\n  function doClean(docToClean, getAutoValues, filter, autoConvert, removeEmptyStrings, trimStrings) {                // 243\n    // Clean the doc/modifier in place                                                                               // 244\n    schema.clean(docToClean, {                                                                                       // 245\n      filter: filter,                                                                                                // 246\n      autoConvert: autoConvert,                                                                                      // 247\n      getAutoValues: getAutoValues,                                                                                  // 248\n      isModifier: (type !== \"insert\"),                                                                               // 249\n      removeEmptyStrings: removeEmptyStrings,                                                                        // 250\n      trimStrings: trimStrings,                                                                                      // 251\n      extendAutoValueContext: _.extend({                                                                             // 252\n        isInsert: (type === \"insert\"),                                                                               // 253\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 254\n        isUpsert: isUpsert,                                                                                          // 255\n        userId: userId,                                                                                              // 256\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 257\n        docId: ((type === \"update\" || type === \"upsert\") && selector) ? selector._id || selector : void 0,           // 258\n        isLocalCollection: isLocalCollection                                                                         // 259\n      }, options.extendAutoValueContext || {})                                                                       // 260\n    });                                                                                                              // 261\n  }                                                                                                                  // 262\n                                                                                                                     // 263\n  // On the server and for local collections, we allow passing `getAutoValues: false` to disable autoValue functions // 264\n  if ((Meteor.isServer || isLocalCollection) && options.getAutoValues === false) {                                   // 265\n    skipAutoValue = true;                                                                                            // 266\n  }                                                                                                                  // 267\n                                                                                                                     // 268\n  // Preliminary cleaning on both client and server. On the server and for local                                     // 269\n  // collections, automatic values will also be set at this point.                                                   // 270\n  doClean(doc, ((Meteor.isServer || isLocalCollection) && !skipAutoValue), options.filter !== false, options.autoConvert !== false, options.removeEmptyStrings !== false, options.trimStrings !== false);\n                                                                                                                     // 272\n  // We clone before validating because in some cases we need to adjust the                                          // 273\n  // object a bit before validating it. If we adjusted `doc` itself, our                                             // 274\n  // changes would persist into the database.                                                                        // 275\n  var docToValidate = {};                                                                                            // 276\n  for (var prop in doc) {                                                                                            // 277\n    // We omit prototype properties when cloning because they will not be valid                                      // 278\n    // and mongo omits them when saving to the database anyway.                                                      // 279\n    if (doc.hasOwnProperty(prop)) {                                                                                  // 280\n      docToValidate[prop] = doc[prop];                                                                               // 281\n    }                                                                                                                // 282\n  }                                                                                                                  // 283\n                                                                                                                     // 284\n  // On the server, upserts are possible; SimpleSchema handles upserts pretty                                        // 285\n  // well by default, but it will not know about the fields in the selector,                                         // 286\n  // which are also stored in the database if an insert is performed. So we                                          // 287\n  // will allow these fields to be considered for validation by adding them                                          // 288\n  // to the $set in the modifier. This is no doubt prone to errors, but there                                        // 289\n  // probably isn't any better way right now.                                                                        // 290\n  if (Meteor.isServer && isUpsert && _.isObject(selector)) {                                                         // 291\n    var set = docToValidate.$set || {};                                                                              // 292\n    docToValidate.$set = _.clone(selector);                                                                          // 293\n    _.extend(docToValidate.$set, set);                                                                               // 294\n  }                                                                                                                  // 295\n                                                                                                                     // 296\n  // Set automatic values for validation on the client.                                                              // 297\n  // On the server, we already updated doc with auto values, but on the client,                                      // 298\n  // we will add them to docToValidate for validation purposes only.                                                 // 299\n  // This is because we want all actual values generated on the server.                                              // 300\n  if (Meteor.isClient && !isLocalCollection) {                                                                       // 301\n    doClean(docToValidate, true, false, false, false, false);                                                        // 302\n  }                                                                                                                  // 303\n                                                                                                                     // 304\n  // Validate doc                                                                                                    // 305\n  var ctx = schema.namedContext(options.validationContext);                                                          // 306\n  var isValid;                                                                                                       // 307\n  if (options.validate === false) {                                                                                  // 308\n    isValid = true;                                                                                                  // 309\n  } else {                                                                                                           // 310\n    isValid = ctx.validate(docToValidate, {                                                                          // 311\n      modifier: (type === \"update\" || type === \"upsert\"),                                                            // 312\n      upsert: isUpsert,                                                                                              // 313\n      extendedCustomContext: _.extend({                                                                              // 314\n        isInsert: (type === \"insert\"),                                                                               // 315\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 316\n        isUpsert: isUpsert,                                                                                          // 317\n        userId: userId,                                                                                              // 318\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 319\n        docId: ((type === \"update\" || type === \"upsert\") && selector) ? selector._id || selector : void 0,           // 320\n        isLocalCollection: isLocalCollection                                                                         // 321\n      }, options.extendedCustomContext || {})                                                                        // 322\n    });                                                                                                              // 323\n  }                                                                                                                  // 324\n                                                                                                                     // 325\n  if (isValid) {                                                                                                     // 326\n    // Add the ID back                                                                                               // 327\n    if (id) {                                                                                                        // 328\n      doc._id = id;                                                                                                  // 329\n    }                                                                                                                // 330\n                                                                                                                     // 331\n    // Update the args to reflect the cleaned doc                                                                    // 332\n    if (type === \"insert\") {                                                                                         // 333\n      args[0] = doc;                                                                                                 // 334\n    } else {                                                                                                         // 335\n      args[1] = doc;                                                                                                 // 336\n    }                                                                                                                // 337\n                                                                                                                     // 338\n    // If callback, set invalidKey when we get a mongo unique error                                                  // 339\n    if (Meteor.isServer && hasCallback) {                                                                            // 340\n      args[last] = wrapCallbackForParsingMongoValidationErrors(self, doc, options.validationContext, args[last]);    // 341\n    }                                                                                                                // 342\n                                                                                                                     // 343\n    return args;                                                                                                     // 344\n  } else {                                                                                                           // 345\n    error = getErrorObject(ctx);                                                                                     // 346\n    if (callback) {                                                                                                  // 347\n      // insert/update/upsert pass `false` when there's an error, so we do that                                      // 348\n      callback(error, false);                                                                                        // 349\n    } else {                                                                                                         // 350\n      throw error;                                                                                                   // 351\n    }                                                                                                                // 352\n  }                                                                                                                  // 353\n}                                                                                                                    // 354\n                                                                                                                     // 355\nfunction getErrorObject(context) {                                                                                   // 356\n  var message, invalidKeys = context.invalidKeys();                                                                  // 357\n  if (invalidKeys.length) {                                                                                          // 358\n    message = context.keyErrorMessage(invalidKeys[0].name);                                                          // 359\n  } else {                                                                                                           // 360\n    message = \"Failed validation\";                                                                                   // 361\n  }                                                                                                                  // 362\n  var error = new Error(message);                                                                                    // 363\n  error.invalidKeys = invalidKeys;                                                                                   // 364\n  error.validationContext = context;                                                                                 // 365\n  // If on the server, we add a sanitized error, too, in case we're                                                  // 366\n  // called from a method.                                                                                           // 367\n  if (Meteor.isServer) {                                                                                             // 368\n    error.sanitizedError = new Meteor.Error(400, message);                                                           // 369\n  }                                                                                                                  // 370\n  return error;                                                                                                      // 371\n}                                                                                                                    // 372\n                                                                                                                     // 373\nfunction addUniqueError(context, errorMessage) {                                                                     // 374\n  var name = errorMessage.split('c2_')[1].split(' ')[0];                                                             // 375\n  var val = errorMessage.split('dup key:')[1].split('\"')[1];                                                         // 376\n  context.addInvalidKeys([{                                                                                          // 377\n    name: name,                                                                                                      // 378\n    type: 'notUnique',                                                                                               // 379\n    value: val                                                                                                       // 380\n  }]);                                                                                                               // 381\n}                                                                                                                    // 382\n                                                                                                                     // 383\nfunction wrapCallbackForParsingMongoValidationErrors(col, doc, vCtx, cb) {                                           // 384\n  return function wrappedCallbackForParsingMongoValidationErrors(error) {                                            // 385\n    if (error && ((error.name === \"MongoError\" && error.code === 11001) || error.message.indexOf('MongoError: E11000' !== -1)) && error.message.indexOf('c2_') !== -1) {\n      var context = col.simpleSchema().namedContext(vCtx);                                                           // 387\n      addUniqueError(context, error.message);                                                                        // 388\n      arguments[0] = getErrorObject(context);                                                                        // 389\n    }                                                                                                                // 390\n    return cb.apply(this, arguments);                                                                                // 391\n  };                                                                                                                 // 392\n}                                                                                                                    // 393\n                                                                                                                     // 394\nfunction wrapCallbackForParsingServerErrors(col, vCtx, cb) {                                                         // 395\n  return function wrappedCallbackForParsingServerErrors(error) {                                                     // 396\n    // Handle our own validation errors                                                                              // 397\n    var context = col.simpleSchema().namedContext(vCtx);                                                             // 398\n    if (error instanceof Meteor.Error && error.error === 400 && error.reason === \"INVALID\" && typeof error.details === \"string\") {\n      var invalidKeysFromServer = EJSON.parse(error.details);                                                        // 400\n      context.addInvalidKeys(invalidKeysFromServer);                                                                 // 401\n      arguments[0] = getErrorObject(context);                                                                        // 402\n    }                                                                                                                // 403\n    // Handle Mongo unique index errors, which are forwarded to the client as 409 errors                             // 404\n    else if (error instanceof Meteor.Error && error.error === 409 && error.reason && error.reason.indexOf('E11000') !== -1 && error.reason.indexOf('c2_') !== -1) {\n      addUniqueError(context, error.reason);                                                                         // 406\n      arguments[0] = getErrorObject(context);                                                                        // 407\n    }                                                                                                                // 408\n    return cb.apply(this, arguments);                                                                                // 409\n  };                                                                                                                 // 410\n}                                                                                                                    // 411\n                                                                                                                     // 412\nvar alreadyInsecured = {};                                                                                           // 413\nfunction keepInsecure(c) {                                                                                           // 414\n  // If insecure package is in use, we need to add allow rules that return                                           // 415\n  // true. Otherwise, it would seemingly turn off insecure mode.                                                     // 416\n  if (Package && Package.insecure && !alreadyInsecured[c._name]) {                                                   // 417\n    c.allow({                                                                                                        // 418\n      insert: function() {                                                                                           // 419\n        return true;                                                                                                 // 420\n      },                                                                                                             // 421\n      update: function() {                                                                                           // 422\n        return true;                                                                                                 // 423\n      },                                                                                                             // 424\n      remove: function () {                                                                                          // 425\n        return true;                                                                                                 // 426\n      },                                                                                                             // 427\n      fetch: [],                                                                                                     // 428\n      transform: null                                                                                                // 429\n    });                                                                                                              // 430\n    alreadyInsecured[c._name] = true;                                                                                // 431\n  }                                                                                                                  // 432\n  // If insecure package is NOT in use, then adding the two deny functions                                           // 433\n  // does not have any effect on the main app's security paradigm. The                                               // 434\n  // user will still be required to add at least one allow function of her                                           // 435\n  // own for each operation for this collection. And the user may still add                                          // 436\n  // additional deny functions, but does not have to.                                                                // 437\n}                                                                                                                    // 438\n                                                                                                                     // 439\nvar alreadyDefined = {};                                                                                             // 440\nfunction defineDeny(c, options) {                                                                                    // 441\n  if (!alreadyDefined[c._name]) {                                                                                    // 442\n                                                                                                                     // 443\n    var isLocalCollection = (c._connection === null);                                                                // 444\n                                                                                                                     // 445\n    // First define deny functions to extend doc with the results of clean                                           // 446\n    // and autovalues. This must be done with \"transform: null\" or we would be                                       // 447\n    // extending a clone of doc and therefore have no effect.                                                        // 448\n    c.deny({                                                                                                         // 449\n      insert: function(userId, doc) {                                                                                // 450\n        var ss = c.simpleSchema();                                                                                   // 451\n        // If _id has already been added, remove it temporarily if it's                                              // 452\n        // not explicitly defined in the schema.                                                                     // 453\n        var id;                                                                                                      // 454\n        if (Meteor.isServer && doc._id && !ss.allowsKey(\"_id\")) {                                                    // 455\n          id = doc._id;                                                                                              // 456\n          delete doc._id;                                                                                            // 457\n        }                                                                                                            // 458\n                                                                                                                     // 459\n        // Referenced doc is cleaned in place                                                                        // 460\n        ss.clean(doc, {                                                                                              // 461\n          isModifier: false,                                                                                         // 462\n          // We don't do these here because they are done on the client if desired                                   // 463\n          filter: false,                                                                                             // 464\n          autoConvert: false,                                                                                        // 465\n          removeEmptyStrings: false,                                                                                 // 466\n          trimStrings: false,                                                                                        // 467\n          extendAutoValueContext: {                                                                                  // 468\n            isInsert: true,                                                                                          // 469\n            isUpdate: false,                                                                                         // 470\n            isUpsert: false,                                                                                         // 471\n            userId: userId,                                                                                          // 472\n            isFromTrustedCode: false,                                                                                // 473\n            docId: id,                                                                                               // 474\n            isLocalCollection: isLocalCollection                                                                     // 475\n          }                                                                                                          // 476\n        });                                                                                                          // 477\n                                                                                                                     // 478\n        // Add the ID back                                                                                           // 479\n        if (id) {                                                                                                    // 480\n          doc._id = id;                                                                                              // 481\n        }                                                                                                            // 482\n                                                                                                                     // 483\n        return false;                                                                                                // 484\n      },                                                                                                             // 485\n      update: function(userId, doc, fields, modifier) {                                                              // 486\n        var ss = c.simpleSchema();                                                                                   // 487\n        // Referenced modifier is cleaned in place                                                                   // 488\n        ss.clean(modifier, {                                                                                         // 489\n          isModifier: true,                                                                                          // 490\n          // We don't do these here because they are done on the client if desired                                   // 491\n          filter: false,                                                                                             // 492\n          autoConvert: false,                                                                                        // 493\n          removeEmptyStrings: false,                                                                                 // 494\n          trimStrings: false,                                                                                        // 495\n          extendAutoValueContext: {                                                                                  // 496\n            isInsert: false,                                                                                         // 497\n            isUpdate: true,                                                                                          // 498\n            isUpsert: false,                                                                                         // 499\n            userId: userId,                                                                                          // 500\n            isFromTrustedCode: false,                                                                                // 501\n            docId: doc && doc._id,                                                                                   // 502\n            isLocalCollection: isLocalCollection                                                                     // 503\n          }                                                                                                          // 504\n        });                                                                                                          // 505\n                                                                                                                     // 506\n        return false;                                                                                                // 507\n      },                                                                                                             // 508\n      fetch: ['_id'],                                                                                                // 509\n      transform: null                                                                                                // 510\n    });                                                                                                              // 511\n                                                                                                                     // 512\n    // Second define deny functions to validate again on the server                                                  // 513\n    // for client-initiated inserts and updates. These should be                                                     // 514\n    // called after the clean/autovalue functions since we're adding                                                 // 515\n    // them after. These must *not* have \"transform: null\" if options.transform is true because                      // 516\n    // we need to pass the doc through any transforms to be sure                                                     // 517\n    // that custom types are properly recognized for type validation.                                                // 518\n    c.deny(_.extend({                                                                                                // 519\n      insert: function(userId, doc) {                                                                                // 520\n        // We pass the false options because we will have done them on client if desired                             // 521\n        doValidate.call(c, \"insert\", [doc, {trimStrings: false, removeEmptyStrings: false, filter: false, autoConvert: false}, function(error) {\n            if (error) {                                                                                             // 523\n              throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                            // 524\n            }                                                                                                        // 525\n          }], true, userId, false);                                                                                  // 526\n                                                                                                                     // 527\n        return false;                                                                                                // 528\n      },                                                                                                             // 529\n      update: function(userId, doc, fields, modifier) {                                                              // 530\n        // NOTE: This will never be an upsert because client-side upserts                                            // 531\n        // are not allowed once you define allow/deny functions.                                                     // 532\n        // We pass the false options because we will have done them on client if desired                             // 533\n        doValidate.call(c, \"update\", [{_id: doc && doc._id}, modifier, {trimStrings: false, removeEmptyStrings: false, filter: false, autoConvert: false}, function(error) {\n            if (error) {                                                                                             // 535\n              throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                            // 536\n            }                                                                                                        // 537\n          }], true, userId, false);                                                                                  // 538\n                                                                                                                     // 539\n        return false;                                                                                                // 540\n      },                                                                                                             // 541\n      fetch: ['_id']                                                                                                 // 542\n    }, options.transform === true ? {} : {transform: null}));                                                        // 543\n                                                                                                                     // 544\n    // note that we've already done this collection so that we don't do it again                                     // 545\n    // if attachSchema is called again                                                                               // 546\n    alreadyDefined[c._name] = true;                                                                                  // 547\n  }                                                                                                                  // 548\n}                                                                                                                    // 549\n                                                                                                                     // 550\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]